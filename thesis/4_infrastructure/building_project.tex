\clearpage
\section{Rozwój systemu budowania projektu (AK)}
\label{ch:building_project}

Pierwsze w pełni przystosowane do pracy z opartą o mechanizm submodułów strukturą projektu wydanie systemu budowania aplikacji oraz bibliotek wchodzących w skład warstwy oprogramowania GGSS przygotowane zostało przez autorów w ramach napisanej przez nich pracy inżynierskiej. Spełniało ono wszystkie podstawione przed nim wtedy wymagania, takie jak możliwość niezależnego budowania pojedynczych komponentów projektu. Jednakże wraz z kontynuacją przez autorów prac nad projektem w ramach niniejszej pracy magisterskiej, pojawiła się możliwość rozwoju stworzonego systemu, co pozwoliłoby uczynić go bardziej niezawodnym i przyjaźniejszym dla użytkownika. Na kolejnych stronach manuskryptu opisane zostały zatem zmiany w systemie budowania projektu GGSS, wprowadzone przez autorów w czasie przygotowywania niniejszej pracy dyplomowej.

\subsection{Wprowadzenie do problematyki}
Przygotowany w ramach pracy inżynierskiej system budowania oparty został o narzędzie CMake oraz, w mniejszym stopniu, o proste skrypty napisane w języku Python. Rezultatem było w pełni działające rozwiązanie, spełniające wszystkie postawione wtedy przed nim wymagania:
\begin{itemize}
    \item niezależność od platformy - system powinien działać poprawnie zarówno na urządzeniach wykorzystujących system operacyjny Linux, jak i na komputerach z Windowsem.
    \item możliwość budowania projektu o skomplikowanej, hierarchicznej strukturze, jakiego jak aplikacja \emph{ggss-runner} wchodząca w skład warstwy oprogramowania GGSS 
    \item możliwość budowania każdego z komponentów systemu z osobna, bez wykorzystywania pozostałych, niepowiązanych z nim modułów
    \item czytelna, jednopoziomowa (brak zagnieżdżeń) wynikowa struktura katalogów, w której każdy zbudowany komponent znajduje się tylko raz, niezależnie od tego, jak wiele modułów było od niego zależnych
\end{itemize}

Ponieważ oprogramowanie systemu GGSS składa się z wielu bibliotek i aplikacji, dla których proces tworzenia przebiega bardzo podobnie, zdecydowano się zastosować rozwiązanie pozwalające na ponowne wykorzystanie poszczególnych komponentów systemu budowania. W tym celu wykorzystywane często funkcjonalności wyodrębnione zostały w postaci osobnych plików \lstinline{.cmake}. W ten sposób do osobnych plików wydzielony został kod odpowiedzialny m.in. za: budowanie bibliotek statycznych, budowanie zależności danego komponentu czy dołączanie do projektu bibliotek Boost i GSL. Następnie tego typu pliki (zwane w dalszej części pracy szablonami CMake) wykorzystywane były w plikach \lstinline{CMakeLists.txt} odpowiedzialnych za budowanie poszczególnych komponentów projektu, co zostało zobrazowane w formie przykładu na listingu \ref{lst:cmake_old}. Zaprezentowany fragment kodu zawiera konfigurację procesu budowania biblioteki \emph{thread-lib}, wraz z komentarzami w języku polskim. 

\lstinputlisting[
    language=CMake, 
    caption={Fragment wykorzystywanego w pierwotnej wersji systemu budowania pliku \lstinline{CMakeLists.txt} zawierający konfigurację procesu tworzenia biblioteki \emph{thread-lib}. Widoczne są przyjęte podczas tworzenia pracy inżynierskiej konwencje dotyczące sposobu wykorzystywania szablonów CMake. }, 
    label={lst:cmake_old}
]{4_infrastructure/code_samples/sample_old_cmake.cmake}

Przykład obrazuje sposób wykorzystywania szablonów CMake, jaki przyjęty został przez autorów podczas tworzenia przez nich pracy inżynierskiej - załączenie pliku za pomocą komendy \lstinline{include()} powodowało zamieszczenie znajdujących się w nim instrukcji bezpośrednio w danym miejscu kodu. Dodatkowo, jeśli zawartość tego typu pliku wymagała od użytkownika wyspecyfikowania dodatkowych informacji, takich jak lista koniecznych do zbudowania zależności, następowało to po prostu poprzez utworzenie (przed miejscem załączenia pliku) zmiennej o odpowiedniej nazwie - na załączonym przykładzie jest to widoczne w przypadku pliku \lstinline{BuildDependencies.cmake}, wymagającego do poprawnego działania istnienia zmiennych \lstinline{dependency_prefix} oraz \lstinline{dependencies}.

\subsection{Motywacja do wprowadzenia zmian}
Przygotowane przez autorów w ramach pracy inżynierskiej rozwiązanie charakteryzowało się pewnymi ograniczeniami, takimi jak brak wsparcia dla testów jednostkowych oraz tworzenia dokumentacji kodu źródłowego za pomocą narzędzia Doxygen. Niewątpliwą wadą przygotowanego rozwiązania był ponadto sposób wykorzystywania szablonów CMake, wymagający od użytkownika znajomości ich zawartości (by wiedzieć, jakie zmienne powinny zostać utworzone, by system działał poprawnie). Znacznie bardziej przyjazną dla użytkownika alternatywą wydaje się być wykorzystanie funkcji i makr, gdzie wszystkie potrzebne informacje przekazywane byłyby w formie argumentów. Ponadto wraz z pojawianiem się w warstwie oprogramowania systemu GGSS kolejnych aplikacji konieczne stało się rozbudowanie skryptu \lstinline{build.py}, znajdującego się w repozytorium \emph{ggss-all} i odpowiadającego za wysokopoziomowe zarządzanie procesem budowania (m.in. wybór między wersja \emph{debug} i \emph{release} oraz statycznym i dynamicznym linkowaniem bibliotek wchodzących w skład pakietu Boost).

\subsection{Zastosowanie funkcji i makr narzędzia CMake}
Jedną z wprowadzonych podczas prac nad systemem budowania projektu GGSS zmian była przebudowa istniejących plików \lstinline{.cmake} poprzez umieszczenie znajdującego się tam kodu w starannie nazwanych funkcjach i makrach. Celem tej modyfikacji było ułatwienie osobom rozwijającym system GGSS dodawania nowych bibliotek i aplikacji. Jak zostało wyżej wspomniane, przed wprowadzeniem omawianej modyfikacji do sprawnego korzystania z przygotowanych szablonów konieczna była znajomość ich zawartości, ponieważ oczekiwały one często wyspecyfikowania wymaganych informacji za pomocą odpowiednio nazwanych zmiennych. Zamiast tego zaproponowane zostało rozwiązanie, w którym wszystkie potrzebne informacje przekazywane są do odpowiedzialnej za daną operację funkcji (lub makra) poprzez nazwane argumenty wywołania. Z punktu widzenia narzędzia CMake funkcjonalność taka dostępna jest przy pomocy komendy \lstinline{cmake_parse_arguments}. Ze względu na trywialny i powtarzalny charakter wprowadzonych w szablonach CMake przekształceń, w niniejszej pracy pominięty został opis implementacji nowego rozwiązania, wskazana została natomiast różnica widoczna z perspektywy osoby wykorzystującej istniejący system budowania. Na listingu \ref{lst:cmake_new} przedstawiony został przykład wykorzystania jednej ze stworzonych przez autorów funkcji: \lstinline{ggss_build_static_library} pochodzącej z szablonu \lstinline{BuildStaticLibrary.cmake}. Przedstawiony fragment kodu wykonuje dokładnie to samo zadanie, co widoczny wcześniej na listingu \ref{lst:cmake_old} - odpowiedzialny jest za konfigurację procesu budowania biblioteki \emph{thread-lib}. Jest on znacznie krótszy od widocznego w poprzednim przykładzie - zostało to osiągnięte poprzez przeniesienie do wnętrza funkcji funkcjonalności takich jak sprawdzenie, czy dany komponent został już przetworzony. Widoczny w przykładzie sposób przekazywania informacji za pomocą nazwanych argumentów funkcji (np. \lstinline{DEPENDENCIES}) jest zdaniem autorów znacznie czytelniejszy od mechanizmu istniejącego w projekcie wcześniej. Ponadto, dzięki wykorzystaniu funkcji, przedstawiony fragment przypomina kod źródłowy napisany za pomocą popularnych języków programowania, takich jak C i C++, co zdaniem autorów czyni go bardziej intuicyjnym.

\lstinputlisting[
    language=CMake, 
    caption={Fragment wykorzystywanego w najnowszej wersji systemu budowania pliku \lstinline{CMakeLists.txt} odpowiedzialnego za konfigurację procesu tworzenia biblioteki \emph{thread-lib}. Widoczne jest wykorzystanie funkcji oraz nazwanych argumentów w celu zwiększenie czytelności prezentowanego kodu.}, 
    label={lst:cmake_new}
]{4_infrastructure/code_samples/sample_new_cmake.cmake}

W sposób podobny do załączanego w przykładzie pliku \lstinline{BuildStaticLibrary.cmake} zmodyfikowane zostały pozostałe wchodzące w skład projektu pliki \lstinline{.cmake} (np. plik \lstinline{BuildDependencies.cmake}, odpowiedzialny za konfigurację zależności danego modułu) dzięki czemu wzrosła jakość kodu wchodzącego w skład systemu budowania. W większości przypadków autorzy zdecydowali się na wykorzystanie funkcji - zastąpienie ich za pomocą makr konieczne było tylko w kilku szczególnych przypadkach. Najważniejszą różnicą między obiema wspomnianymi konstrukcjami jest fakt, iż w ciele funkcji, w przeciwieństwie do marka, tworzony jest nowy zasięg widoczności zmiennych (ang. \emph{scope}), przez co skutki zachodzących w jej wnętrzu zmian, takich jak przypisania, nie są domyślnie widoczne poza nią. Zastosowane zmiany zgodne są ponadto z konwencją, wedle której napisany za pomocą narzędzia CMake kod systemu budowania powinien być traktowany na równi z kodem źródłowym przetwarzanych przez niego aplikacji i bibliotek. 

\subsection{Wsparcie dla testów jednostkowych i dokumentacji}
Kolejną wprowadzona przez autorów modyfikacją było dodanie, na poziomie systemu budowania, wsparcia dla testów jednostkowych oraz generowania, za pomocą narzędzia Doxygen, dokumentacji kodu źródłowego. Ponieważ obie wprowadzone funkcjonalności wykorzystywane są przez wiele komponentów projektu, ich implementacja zamieszczona została w znajdujących się aktualnie w repozytorium \emph{ggss-util-libs} plikach \lstinline{.cmake}, kolejno: \lstinline{SetupTests.cmake} i \lstinline{SetupDoxygen.cmake}. Zgodnie ze stosowaną w projekcie konwencją, również te funkcjonalności zaimplementowane zostały w postaci funkcji (w przypadku dokumentacji) oraz makra (w przypadku testów, gdzie zostało to wymuszone z uwagi na konieczność wywołania polecenia \lstinline{enable_testing} w odpowiednim zasięgu widoczności zmiennych). 


Znajdująca się w pliku \lstinline{SetupDoxygen.cmake} funkcja \lstinline{ggss_setup_doxygen} wywoływana jest w ciele odpowiedzialnej za konfigurację procesu budowania bibliotek statycznych funkcji \lstinline{ggss_build_static_library} (listing \ref{lst:cmake_doxygen}). Dzięki temu proces generowania dokumentacji konfigurowany jest automatycznie dla każdego modułu dodawanego do projektu. Poza wspomnianym szablonem CMake, w repozytorium \emph{ggss-util-libs} utworzony został katalog \lstinline{doxygen-config}, zawierający plik konfigurujący działanie narzędzia Doxygen (np. poprzez aktywację funkcjonalności rekurencyjnego przeszukiwania katalogów wchodzących w skład dokumentowanego komponentu). Użytkownik ma możliwość generowania dokumentacji w formacie HTML dla każdego komponentu projektu poprzez wykonanie polecenia \lstinline{make <nazwa-komponentu>-docs}, np. \lstinline{make xml-docs} powoduje wygenerowanie dokumentacji biblioteki odpowiedzialnej za obsługę plików XML.

\lstinputlisting[
    language=CMake, 
    caption={Fragment pliku \lstinline{BuildStaticLibrary.cmake}, przedstawiający wywołanie funkcji odpowiedzialnej za konfigurację procesu generowania dokumentacji za pomocą narzędzia Doxygen.}, 
    label={lst:cmake_doxygen}
]{4_infrastructure/code_samples/doxygen_cmake.cmake}


Zgodnie z założeniem, że mechanizm testów jednostkowych jest opcjonalny dla każdego z modułów warstwy oprogramowania systemu GGSS, wywołanie znajdującego się w pliku \lstinline{SetupTests.cmake} makra \lstinline{ggss_setup_tests} nie następuje w żadnym ze zdefiniowanych przez autorów szablonów CMake. Zamiast tego programista przygotowujący dany komponent podejmuje decyzję o wykorzystaniu tej funkcjonalności, co zostało przedstawione na listingu \ref{lst:cmake_ctest}, gdzie zamieszczony został fragment pliki \lstinline{CMakeLists.txt} konfigurujący proces budowania biblioteki \emph{fifo-lib} oraz przygotowanych dla niej testów jednostkowych. Z punktu widzenia systemu budowania wsparcie dla tego typu testów oparte zostało o narzędzie CTest. Każdy z plików \lstinline{.cpp} znajdujących się w katalogu \lstinline{test} (usytuowanym na tym samy poziomie co katalogi zawierające pliki źródłowe i nagłówkowe tworzonego komponentu) wykorzystywany jest do stworzenia osobnego testu za pomocą komendy \lstinline{add_test}. Uruchomienie testów możliwe jest na kilka sposobów, jednym z nich jest wykonanie polecenia \lstinline{ctest --verbose} z poziomu katalogu, w którym przeprowadzany jest proces budowania testowanego modułu.

\clearpage
\lstinputlisting[
    language=CMake, 
    caption={Fragment pliku \lstinline{CMakeLists.txt}, przedstawiający wykorzystanie funkcji 
    konfigurującej proces budowania modułu \emph{fifo-lib} oraz makra odpowiedzialnego za obsługę przygotowanych dla niego testów jednostkowych. W celu zapewnienia poprawnego działania systemu budowania konieczne jest zachowanie odpowiedniej, zgodnej z przykładem, kolejności wywołań.}, 
    label={lst:cmake_ctest}
]{4_infrastructure/code_samples/ctest_cmake.cmake}


\subsection{Rozbudowa skryptu konfigurującego proces budowania projektu}
Znajdujący się w repozytorium \emph{ggss-all} skrypt \lstinline{build.py} odpowiedzialny jest za przeprowadzanie wysokopoziomowej konfiguracji procesu budowania całego projektu (możliwy jest m.in. wybór budowanych komponentów systemu). Względem wersji skryptu przygotowanej przez autorów w ramach pracy inżynierskiej wprowadzone zostały niewielkie zmiany. Najważniejszą z nich jest zmiana sposobu, w jaki użytkownik dokonuje wyboru budowanych modułów. W pierwotnej wersji skryptu dokonywane to było poprzez wywołanie go ze specjalnymi argumentami powodującymi wykluczenie poszczególnych komponentów z procesu budowania (np. zastosowanie argumentu \lstinline{--norunner} powodowało pominięcie w procesie budowania aplikacji \emph{ggss-runner}). Wraz ze wzrostem liczby budowanych komponentów takie podejście stało się niepraktyczne, zastąpione zostało zatem przekazywaniem do skryptu argumentu \lstinline{--apps} wraz z listą budowanych modułów. Po wprowadzeniu zmian następujące wywołanie: \lstinline{build.py --apps runner dimcs} powoduje zbudowanie dwóch komponentów systemu: aplikacji \emph{ggss-runner} oraz \emph{dim-cs}. Ponadto dodane zostało wsparcie dla omawianego w dalszej części pracy mechanizmu wersjonowania (argument \lstinline{--version}). Na listingu \ref{lst:build_py} przedstawiony został wynik wywołania skryptu z argumentem \lstinline{--help}, powodującym wypisanie informacji na temat sposobu jego użytkowania.

\lstinputlisting[
    language=Cmd, 
    caption={Wynik wywołania skryptu \lstinline{build.py} z argumentem \lstinline{--help}, powodującym wypisanie informacji na temat sposobu jego wykorzystywania.}, 
    label={lst:build_py}
]{4_infrastructure/code_samples/buildpy_help.txt}