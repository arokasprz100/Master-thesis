\chapter{Prace nad kodem źródłowym projektu (AK)}
\label{cha:code}

% setup
\graphicspath{{5_code/static/}}

Niniejszy rozdział stanowi opis wprowadzonych przez autorów zmian w~kodzie źródłowym aplikacji \emph{ggss-runner}, stanowiącej trzon warstwy oprogramowania systemu GGSS. Opis poszczególnych modyfikacji poprzedzony został krótkim wprowadzeniem, opisującym wysokopoziomowe działanie omawianego programu oraz wynikające z~jego specyfiki ograniczenia i~założenia. Omówienie wprowadzonych zmian podzielone zostało na dwie części. W~pierwszej z~nich przedstawione zostały modyfikacje nie mające wpływu na sposób działania aplikacji, ale poprawiające jakość jej kodu źródłowego, np. poprzez jego migrację do nowszego standardu języka C++. Druga część stanowi natomiast opis nowych funkcjonalności oraz rozszerzeń wprowadzonych przez autorów do projektu. 

\section{Analiza aplikacji \emph{ggss-runner}}
Omawiana aplikacja stanowi trzon warstwy oprogramowania systemu GGSS, a~jej zadaniem jest cykliczne gromadzenie danych w~postaci widma poprzez komunikację z~wielokanałowym analizatorem amplitudy oraz wyznaczanie na ich podstawie odpowiedniej wartości napięcia, pozwalającego uzyskać stałe wzmocnienie gazowe. Analizowany program odpowiada za komunikację z~urządzeniami wchodzącymi w~skład systemu GGSS - w~tym celu wykorzystywany jest port szeregowy. Aplikacja zaimplementowana została w~swojej oryginalnej wersji jako program wielowątkowy, w~którym kluczową rolę pełnią dwa wątki. Jeden z~nich odpowiedzialny jest za wykonywanie logiki związanej z~przeprowadzaniem pomiarów, drugi zaś zapewnia komunikację z~użytkownikiem za pomocą systemu komend wysyłanych do aplikacji za pomocą interfejsu DIM. Pozostałe tworzone w~programie wątki odpowiadają za wykonywanie pomniejszych czynności, takich jak obsługa dziennika zdarzeń.

Działanie wątku odpowiedzialnego za przeprowadzanie cyklicznych pomiarów z~wykorzystaniem wielokanałowego analizatora amplitudy oraz słomkowych liczników proporcjonalnych przedstawione zostało, w~wysokopoziomowym, uproszczonym ujęciu, na rysunku \ref{fig:flow_main}. Użytkownik, za pomocą umieszczonego w~pliku konfiguracyjnym parametru określa, które z~liczników słomkowych obecnych w~projekcie powinny być wykorzystywane do przeprowadzenia pomiarów. Wykorzystywane liczniki pogrupowane są w~tzw. pudełka (ang. \emph{box}), numeracja poszczególnych kanałów ma zatem następujący format: \lstinline{<numer_pudełka>:<numer_licznika>}. Przykładowo, użytkownik może określić następującą kolejność wykonywania pomiarów: \lstinline{0:2,0:4,0:6,0:7,0:1}, co oznacza, że wykorzystywane jest 5~liczników wchodzących w~skład pudełka 0. Podczas obsługi pojedynczego kanału wykonywana jest akwizycja danych w~postaci widma. Następnie zbierane dane są opracowywane i~przesyłane do systemu DCS za pomocą interfejsu DIM, a~system przechodzi do kolejnego licznika określonego według wyżej wspomnianej kolejności. Pojedyncza iteracja to wykonanie pomiaru na wszystkich określonych przez użytkownika kanałach - proces ten powtarzany jest aż do momentu zakończenia działania programu.


\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{flow.pdf}
\caption{Uproszczony schemat działania wątku aplikacji \emph{ggss-runner} odpowiedzialnego za wykonywanie cyklicznych pomiarów.}
\label{fig:flow_main}
\end{figure}

Na opracowanie danych zebranych za pomocą pojedynczego licznika składa się szereg czynności. W~pierwszej kolejności dopasowywana jest do nich odpowiednia krzywa. Jej parametry poddawane są następnie walidacji (co może powodować wystąpienie błędu lub ostrzeżenia) oraz za ich pomocą wyznaczana jest nowa wartość napięcia referencyjnego, które następnie jest aktualizowane na zasilaczu wysokiego napięcia. Zebrane dane oraz wyniki ich opracowania zapisywane są do plików oraz przesyłane, za pośrednictwem interfejsu DIM, do systemu DCS. Aplikacja przechowuje ponadto wyniki kilku (domyślnie pięciu) ostatnich pomiarów dla każdego z~kanałów.

Zadaniem drugiego ze wspomnianych wcześniej wątków jest komunikacja z~użytkownikiem za pomocą zestawu komend przesyłanych za pośrednictwem protokołu DIM. Zastosowanie tych poleceń jest bardzo szerokie, od zmiany wartości pojedynczego parametru systemu, do jego całkowitego zatrzymania lub ponownej konfiguracji. Istotny jest fakt, że może to mieć bezpośredni wpływ na działanie wątku odpowiedzialnego za przeprowadzanie pomiarów - dlatego też zaprezentowany wcześniej na rys. \ref{fig:flow_main} schemat jest uproszczeniem - nie bierze on pod uwagę tego typu interakcji. Przykładem możliwej do wykonania komendy jest polecenie \lstinline{stop}, zatrzymujące wykonywanie pomiarów (jednak nie samo działanie aplikacji).

Z~punktu widzenia architektury aplikacja składa się z~szeregu modułów, zaimplementowanych w~postaci bibliotek statycznych, których zastosowanie obejmuje m.in. implementację dziennika zdarzeń, mechanizmu sygnałów i~slotów czy też przeprowadzanie interakcji w~określonym urządzeniem elektronicznym. Niestety modularne podejście nie zostało zastosowane w~przypadku implementacji głównej logiki aplikacji - tzn. przeprowadzania pomiarów oraz zapewniania komunikacji za pomocą komend. Wszystkie te funkcjonalności zawarte zostały w~bibliotece \emph{ggss-lib}, w~ramach dwóch klas charakteryzujących się bardzo dużym rozmiarem. Stworzone za ich pomocą obiekty stanowią przykład tzw. \emph{God objects} - antywzorca projektowego polegającego na zawieraniu bardzo wielu odpowiedzialności w~pojedynczym komponencie projektu. Jest to duży mankament, mający znaczący wpływ na sposób wykonywania zaprezentowanych w~niniejszym manuskrypcie prac, powodujący trudności m.in. z~implementacją automatycznych testów. 

Aplikacja w~swojej oryginalnej wersji napisana została z~wykorzystaniem języka C++, w~znacznej większości w~standardzie C++03 (aczkolwiek w~kodzie zaobserwowane zostało wykorzystanie elementów standardu C++11). Wykorzystuje ona niektóre elementy zestawu bibliotek Boost oraz bibliotekę GSL. Ponadto program wykorzystuje zewnętrzne moduły napisane w~języku C, odpowiedzialne m.in. za obsługę wielokanałowego analizatora amplitudy.

\clearpage
\section{Specyfika i~metodyka pracy}
Rozwój systemu działającego przez wiele lat w~dedykowanym środowisku produkcyjnym, charakteryzującego się bardzo wysoką niezawodnością, wymagał od autorów dostosowania sposobu pracy w~taki sposób, by wprowadzone zmiany nie miały negatywnego wpływu na jakość działania projektu. Wprowadzanie udoskonaleń w~powstałym przed laty kodzie źródłowym niesie ze sobą dodatkowe wyzwania, wynikające m.in. ze sposobu, w~jaki oryginalnie zaprojektowany został system (brak ogólnie przyjętych dziś praktyk programistycznych). Dlatego też pracując nad aplikacją \emph{ggss-runner}, autorzy zdecydowali się na przyjęcie szeregu ograniczeń i~praktyk, mających na celu ułatwienie pracy z~jej kodem źródłowym oraz utrzymanie jej wysokiej niezawodności, m.in. poprzez wczesne wykrywanie błędów. Należą do nich m.in.: wymóg przygotowywania testów jednostkowych (uruchamianych automatycznie w~ramach procesu ciągłej integracji) dla każdego modyfikowanego lub tworzonego modułu projektu, dla którego było to możliwe, ograniczenie zakresu wprowadzanych zmian oraz wymóg, by każda wprowadzana zmiana, przed jej dołączeniem do gałęzi głównej danego modułu, poddawana była inspekcji wykonywanej przez pozostałych członków zespołu (tzw. \emph{code review}).


\subsection{Testy jednostkowe}
Celem testów jednostkowych jest sprawdzenie poprawności działania pojedynczego elementu systemu, rozumianego jako implementacja określonej funkcjonalności wchodzącej w~skład logiki biznesowej projektu. Mówiąc inaczej, celem testów jednostkowych jest sprawdzenie zachowania testowanego komponentu (mogącego być, w~zależności od konkretnego przypadku, pojedynczą funkcją, klasą czy też całym modułem), nie zaś weryfikacja szczegółów implementacyjnych. Powinny być one przygotowywane w~ten sposób, by możliwe było ich automatyczne uruchomienie w~celu weryfikacji każdej wprowadzanej przez programistę zmiany (np. po umieszczeniu nowej rewizji w~portalu GitLab). 

Autorzy zdecydowali się na przygotowywanie testów jednostkowych dla każdego modyfikowanego komponentu wchodzącego w~skład aplikacji \emph{ggss-runner}, dla którego istniała taka możliwość. Dzięki temu możliwe było sprawdzenie, w~jaki sposób działał dany element projektu przed wprowadzeniem poprawek lub rozszerzeń, oraz czy dokonanie modyfikacji nie skutkowało nieoczekiwaną zmianą sposobu jego funkcjonowania. Projekt w~swojej pierwotnej wersji nie posiadał żadnego zautomatyzowanego systemu testowania, a~zatem konieczne było wprowadzenie go od podstaw (zarówno na poziomie systemu budowania, ciągłej integracji i~dostarczania, jak i~na poziomie kodu źródłowego). Motywacją do zastosowania tego typu podejścia był wymóg zachowania niezawodności aplikacji \emph{ggss-runner} oraz fakt, iż testy jednostkowe stanowią współcześnie szeroko stosowaną praktykę. 

W~celu tworzenia testów jednostkowych autorzy wykorzystali bibliotekę \emph{Boost.Test}. Pozwala ona dokonywać sprawdzeń takich jak porównanie wartości zwracanej przez funkcję do wartości oczekiwanej czy weryfikacja rzucenia określonego typu wyjątku. Biblioteka ta oferuje zatem podstawowe funkcjonalności pozwalające na testowanie projektu, jednakże z~punktu widzenia systemu GGSS jest ona wystarczająca. Jej dodatkową zaletą, istotną z~punktu widzenia przyjętych podczas prac nad projektem ograniczeń, brak konieczności wprowadzania dodatkowych zewnętrznych zależności, ponieważ aplikacja \emph{ggss-runner} korzystała już w~swojej pierwotnej wersji z~pakietu Boost.

Na listingu \ref{lst:example_tests} przedstawione zostały dwa przykładowe testy jednostkowe przygotowane przez autorów podczas prac nad projektem. Testom poddawany jest wchodzący w~skład biblioteki \emph{fifo-lib} szablon klasy \lstinline{QueueLimited}, którego zadaniem jest implementacja generycznej kolejki o~określonym rozmiarze, po przekroczeniu którego usunięty zostaje najstarszy znajdujący się w~niej element (funkcjonalność ta wykorzystywana jest w~aplikacji \emph{ggss-runner} do przechowywania wyników kilku ostatnich pomiarów wykonanych za pomocą danego detektora słomkowego). Ponieważ celem przykładu jest zaprezentowanie mechanizmu testów jednostkowych, nie zaś sposobu działania testowanej kolejki, przedstawione na nim zostały bardzo proste sprawdzenia. Testy weryfikują, czy utworzona za pomocą domyślnego konstruktora struktura nie posiada żadnych elementów oraz czy próba pobrania elementu z~pustej kolejki zakończy się rzuceniem wyjątku.

\lstinputlisting[
    language=C++, 
    caption={Przykład stworzonych na potrzeby projektu GGSS testów jednostkowych, weryfikujących poprawność działania podstawowych operacji wykonywanych na testowanym komponencie - w~tym przypadku jest to szablon klasy implementującej kolejkę o~ograniczonym rozmiarze.}, 
    label={lst:example_tests}
]{5_code/code_samples/example_tests.cpp}

W~przypadku pierwszego z~zaprezentowanych testów widoczne jest zastosowanie konstrukcji \lstinline{BOOST_CHECK_EQUAL}, sprawdzającej równość przekazanych do niej argumentów, co pozwala zweryfikować, że rozmiar utworzonej w~domyślny sposób kolejki jest równy 0. W~przypadku drugiego testu zastosowane zostało makro \lstinline{BOOST_CHECK_THROW} pozwalające zweryfikować, czy wykonanie przekazanego kodu powoduje wyrzucenie określonego typu wyjątku (tutaj: \lstinline{QueueLimited<int>::ReadEmptyQueueException}). Oczywiście zaprezentowany przykład nie wyczerpuje możliwości oferowanych przez zastosowaną bibliotekę, takich jak tworzenie wspólnych dla wielu testów konfiguracji (tzw. \emph{test fixtures}), pozwalających m.in. na zdefiniowanie pewnego stanu początkowego.

Jak wspomniano, zaletą testów jednostkowych jest możliwość wykonywania ich automatycznie, np. podczas wdrażania nowej rewizji w~zdalnym repozytorium. Przykładem tego typu funkcjonalności jest technologia GitLab CI/CD, wspierająca proces ciągłej integracji i~dostarczania. Mechanizm CI/CD zintegrowany został z~projektem GGSS w~ramach przygotowanej przez autorów pracy inżynierskiej (obejmował wtedy przede wszystkim proces automatycznego budowania poszczególnych komponentów systemu) oraz rozbudowany o~możliwość wykonywania automatycznych testów w~ramach niniejszej pracy magisterskiej. Rysunek \ref{fig:cicd_tests} przedstawia graficzną reprezentację procesu ciągłej integracji i~dostarczania (tzw. \emph{pipeline}) zdefiniowanego dla wchodzącego w~skład projektu repozytorium \emph{ggss-software-libs}. Zaprezentowany w~tym przypadku proces składa się z~dwóch etapów (ang. \emph{stages}), z~czego drugi stanowi nowość wprowadzoną w~ramach niniejszej pracy - wykonanie testów jednostkowych. 

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{pipeline.png}
\caption{Graficzna reprezentacja przebiegu procesu ciągłej integracji i~dostarczania zdefiniowanego dla repozytorium \emph{ggss-software-libs}. Przeprowadzane działania podzielone zostały na dwa etapy, z~czego drugi (\emph{Test}) odpowiada za automatyczne wykonanie znajdujących się w~projekcie testów jednostkowych.}
\label{fig:cicd_tests}
\end{figure}

\clearpage
\subsection{Zakres wprowadzanych zmian}
Istotnym ograniczeniem przyjętym przez autorów podczas wykonywania prac nad projektem było ograniczenie zakresu możliwych do wprowadzenia zmian. Wprowadzanie zmian i~nowych funkcjonalności do istniejącego systemu możliwe jest na wiele sposobów, w~tym poprzez: 
\begin{itemize}
    \item pracę z~istniejącą architekturą systemu, dostosowując do niej sposób implementacji wprowadzanych zmian
    \item przepisanie projektu (pełne lub dotyczące jedynie wybranych komponentów) na nową, nowocześniejszą architekturę
\end{itemize}
Ze względu na fakt, iż jednym ze stawianych przed systemem GGSS wymogów jest jego wysoka niezawodność, a~ponadto charakteryzuje się on znaczącym poziomem skomplikowania (do jego pełnego zrozumienia wymagana jest wiedza domenowa z~zakresu fizyki wykraczająca poza zakres niniejszej pracy) zdecydowano się postępować zgodnie z~pierwszym z~wymienionych podejść. Dlatego też wprowadzane przez autorów modyfikacje miały przede wszystkim charakter niewielkich, zwykle zamykających się w~obrębie jednego lub dwóch modułów, zmian mających udoskonalić sposób działania systemu. 

\subsection{Przyjęte ograniczenia}
Poza do tej pory wspomnianymi, podczas prac nad rozwojem systemu GGSS autorzy stosowali szereg pomniejszych ograniczeń. Jednym z~nich był brak możliwości wprowadzania do projektu jakichkolwiek nowych zależności zewnętrznych, aby nie komplikować sposobu jego budowania i~dystrybucji. Ponadto istotnym było zachowanie zgodności projektu ze środowiskiem docelowym oraz zachowanie wstecznej kompatybilności z~wcześniejszymi wersjami aplikacji \emph{ggss-runner}. Ostatni w~wymienionych wymogów w~sposób znaczący wpływał na sposób, w~jaki implementowane był niektóre z~nowych funkcjonalności - np. jeśli wprowadzony do aplikacji algorytm wymagał znajomości zdefiniowanej w~pliku konfiguracyjnym wartości, nieobecnej tam w~pierwotnej wersji projektu, to implementacja powinna przewidywać brak takiego parametru (np. poprzez zdefiniowanie wartości domyślnej). Ostatnim istotnym ograniczeniem był sposób, w~jaki nowe zmiany integrowane mogły być z~główną gałęzią danego modułu - wymagało to wykonania, przez innego niż osoba dokonująca zmian członka zespołu, inspekcji wprowadzonych modyfikacji.

\clearpage
\section{Poprawa jakości kodu źródłowego}
Niniejsza część pracy opisuje wybrane zmiany dokonane przez autorów w~celu zwiększenia jakości kodu źródłowego wchodzącego w~skład aplikacji \emph{ggss-runner} i~wszystkich jej zależności. Opisane tu zmiany wykonywane były przede wszystkim w~początkowym etapie prowadzonych prac, a~ich celem, poza poprawą błędów czy unowocześnieniem kodu źródłowego, było umożliwienie autorom dokładnego zapoznania się ze strukturą projektu oraz zrozumienie zasady działania poszczególnych jego modułów oraz systemu jako całości. Proces wprowadzania do projektu opisanych modyfikacji wspomagany był przez wykorzystanie omówionych we wstępie teoretycznym narzędzi służących do przeprowadzania statycznej analizy kodu źródłowego. 

\subsection{Migracja do standardu C++11}
Jednym z~celów niniejszej pracy była modernizacja kodu źródłowego aplikacji \emph{ggss-runner} poprzez przeprowadzenie jego migracji do standardu C++11, będącego najnowszym dostępnym w~ramach wykorzystywanej infrastruktury wydaniem języka C++. Zastosowanie nowszego standardu miało na celu zwiększenie czytelności i~bezpieczeństwa kodu źródłowego oraz wyeliminowanie, tam gdzie było to możliwe, zależności od bibliotek zewnętrznych, takich jak Boost. Przeprowadzone zmiany nie mogły stanowić jednak pełnej migracji - wynika to przede wszystkim z~ograniczeń środowiska docelowego (stosowany tam kompilator nie wspiera standardu w~pełni, np. nie jest możliwe poprawne wykorzystanie nagłówka \lstinline{<regex>}) oraz brak odpowiedników niektórych oferowanych przez Boost funkcjonalności, takich jak mechanizm slotów i~sygnałów, w~bibliotece standardowej.

Wprowadzane modyfikacje miały w~większości charakter niewielkich, lokalnych zmian, niewywierających znaczącego wpływu na funkcjonalności implementowane przez poszczególne moduły projektu. Autorzy wprowadzili różnego typu usprawnienia w~niemal każdym komponencie systemu, przez co niemożliwym jest zawarcie w~pracy zestawienia prezentującego wszystkie poprawki. Dlatego też zdecydowano się na zaprezentowanie, w~kolejnych akapitach niniejszej części manuskryptu, jedynie wybranego podzbioru wprowadzonych zmian, wzbogacając opis o~przykłady w~postaci fragmentów kodu pochodzących bezpośrednio z~projektu. 

Jedną z~najczęściej wprowadzanych modyfikacji było zastąpienie jawnie wykorzystującej mechanizm iteratorów pętli \lstinline{for} jej zakresowym odpowiednikiem. Zmiana ta, pomimo swojej prostoty, pozwala w~sposób znaczący zredukować poziom skomplikowania niewielkiego fragmentu kodu. Pochodzący z~biblioteki \emph{ggss-lib} przykład takiej zmiany zawarty został na listingach \ref{lst:for_before} (wersja oryginalna) oraz \ref{lst:for_after} (wersja po wprowadzeniu modyfikacji). Wynikowy fragment kodu jest krótszy, dzięki czemu pracującemu z~nim programiście łatwiej skupić się na implementowanej logice biznesowej. Zastosowanie słowa kluczowego \lstinline{auto} pozwoliło ponadto uniknąć jawnego specyfikowania typu, na jakim wykonywane są operacje.

\lstinputlisting[
    language=C++, 
    caption={Fragment kodu źródłowego przed wprowadzeniem zmian: przykład zastosowania pętli \lstinline{for} wykorzystującej w~sposób jawny pochodzący ze standardowej biblioteki szablonów mechanizm iteratorów.}, 
    label={lst:for_before}
]{5_code/code_samples/for_loop_before.cpp}

\lstinputlisting[
    language=C++, 
    caption={Fragment kodu źródłowego po wprowadzeniu zmian: przykład zastosowania zakresowej pętli \lstinline{for} oraz słowa kluczowego \lstinline{auto} w~celu zwiększenia czytelności oraz skrócenia fragmentu kodu zaprezentowanego na listingu \ref{lst:for_before}.}, 
    label={lst:for_after}
]{5_code/code_samples/for_loop_after.cpp}

Ponadto zastąpiono znane z~języka C~typy wyliczeniowe (\lstinline{enum}) ich nowocześniejszym odpowiednikiem - silnymi typami wyliczeniowymi (\lstinline{enum class/struct}). Na listingu \ref{lst:enum_before} zamieszczony został pochodzący z~biblioteki \emph{log-lib} fragment kodu, przedstawiający wykorzystanie starszej konstrukcji. Jej zastosowanie wiąże się z~szeregiem wad, m.in. nie definiuje ona nowego zakresu, przez co zawarte w~niej nazwy mogą potencjalnie tworzyć konflikt np. z~innym typem wyliczeniowym. Znane z~języka C~rozwiązanie pozwala zatem na stosowanie zapisu \lstinline{int x~= trace} - tzn. nie jest konieczne wyspecyfikowanie nazwy typu wyliczeniowego. Przedstawiony przykład obrazuje jeszcze jedną niedogodność związaną z~wykorzystywaniem typów wyliczeniowych - możliwość przeprowadzania niejawnych konwersji do typu całkowitoliczbowego, by np. wykorzystać go w~formie indeksu tablicy. Pomimo, że daje do programiście dodatkowe możliwości, do komplikuje tworzony kod poprzez dodanie do niego niewidocznych na pierwszy rzut oka przekształceń, co w~wielu przypadkach uważane jest za złą praktykę, ponieważ jest sprzeczne z~ideą tzw. \emph{samodokumentującego się kodu}.

\lstinputlisting[
    language=C++, 
    caption={Fragment kodu źródłowego przed wprowadzeniem zmian: przykładowe wykorzystanie typu wyliczeniowego - widoczna możliwość dokonania niejawnej konwersji do typu całkowitoliczbowego.}, 
    label={lst:enum_before}
]{5_code/code_samples/enum_before.cpp}

Listing \ref{lst:enum_after} przedstawia analogiczny fragment kodu, wykorzystujący silne typy wyliczeniowe. W~stosunku do poprzedniego przykładu, w~tym przypadku jawnie przypisano oczekiwane wartości do każdego z~wystąpień w~wyliczeniu - dzięki temu stosowanie ich jako indeksów tablicy jest bezpieczniejsze. Ponadto konieczna jest jawna konwersja do typu całkowitoliczbowego, wykonana za pomocą operatora \lstinline{static_cast}. Stosując silne typy wyliczeniowe programista nie stwarza możliwości wystąpienia konfliktu nazw, ponieważ definiują one nowy zakres. Zatem, by uzyskać wartość liczbową, należy wykonać operację \lstinline{int x~= static_cast<int>(SeverityLevel::trace)}.

\lstinputlisting[
    language=C++, 
    caption={Fragment kodu źródłowego po wprowadzeniu zmian: wykorzystanie silnego typu wyliczeniowego, uniemożliwiającego niejawną konwersję do typu całkowitoliczbowego.}, 
    label={lst:enum_after}
]{5_code/code_samples/enum_after.cpp}

Autorzy zdecydowali się ponadto na wyeliminowanie z~kodu źródłowego przestarzałych konstrukcji i~zastąpienie ich odpowiednikami dostarczanymi przez standard C++11. Przykładem tego typu 
modyfikacji było zastąpienie, w~kontekście tzw. dynamicznej specyfikacji wyjątków, słowa kluczowego \lstinline{throw} za pomocą specyfikatora \lstinline{noexcept}. Celem stosowania tych konstrukcji jest wskazanie intencji programisty na temat tego, czy stworzona funkcja może (pośrednio lub bezpośrednio) rzucić wyjątek. Pozorną zaletą specyfikatora \lstinline{throw} była ponadto możliwość zawarcia w~kodzie informacji na temat typów rzucanych przez funkcję wyjątków. W~rzeczywistości jednak stosowanie go ograniczało możliwości rozszerzania i~modyfikacji kodu, ponieważ mogło spowodować krytyczny błąd w~działaniu programu - jeśli rzucony został wyjątek inny, niż zostało zadeklarowane, to wykonanie programu było przerywane. Z~tego też powodu jedynym stosunkowo bezpiecznym sposobem na wykorzystanie tej konstrukcji było wyspecyfikowanie, czy dana funkcja rzuca jakiekolwiek wyjątki. Ta sama funkcjonalność możliwa jest do uzyskania z~wykorzystaniem wprowadzonego w~standardzie C++11 specyfikatora \lstinline{noexcept} - pozwala on zawrzeć w~deklaracji funkcji binarną informację na temat możliwości wyrzucenia wyjątku, a~ponadto wspiera możliwość jej ewaluacji w~czasie kompilacji. Przykład zastosowania zawarty został na pochodzącym z~biblioteki \emph{caenn1470-lib} listingu \ref{lst:noexcept}. 

\clearpage
\lstinputlisting[
    language=C++, 
    caption={Przykład zastosowania specyfikatora \lstinline{noexcept} w~kodzie projektu GGSS w~celu zadeklarowania, że zaprezentowana metoda nie powinna rzucać wyjątków.}, 
    label={lst:noexcept}
]{5_code/code_samples/noexcept.cpp}


Standard C++11 wprowadza ponadto możliwość stosowania tzw. domyślnej inicjalizacji składowych (ang. \emph{default member initialization}), co pozwala nadawać domyślne wartości niestatycznym polom klasy, dzięki czemu możliwe jest uproszczenie istniejących w~projekcie klas, np. poprzez likwidację niektórych konstruktorów. Na listingu \ref{lst:init_before} przedstawiona została uproszczona (pominięte zostały niektóre pola) struktura \lstinline{CaenHVParams}, pochodząca z~biblioteki \emph{caenhv-lib} w~wersji zgodnej ze standardem C++03. Widoczny jest zdefiniowany w~klasie konstruktor, którego celem jest nadanie wartości składowym tworzonego obiektu, zarówno za pomocą listy inicjalizacyjnej, jak i~znajdującej się w~jego ciele pętli \lstinline{for}.


\lstinputlisting[
    language=C++, 
    caption={Fragment kodu źródłowego przed wprowadzeniem zmian: inicjalizacja niestatycznych składowych struktury za pomocą konstruktora.}, 
    label={lst:init_before}
]{5_code/code_samples/init_before.cpp}


Na listingu \ref{lst:init_after} zaprezentowany został natomiast analogiczny kod napisany z~wykorzystaniem standardu C++11. Wynikowa struktura jest znacznie prostsza od swojej pierwotnej wersji, przede wszystkim za sprawą zastąpienia inicjalizacji składowych na poziomie konstruktora przez inicjalizację domyślną. Ponadto w~swojej finalnej postaci struktura znacznie lepiej dokumentuje swoje przeznaczenie - jest to prosty, nieposiadający żadnych metod implementujących logikę, agregat. 

\clearpage
\lstinputlisting[
    language=C++, 
    caption={Fragment kodu źródłowego po wprowadzeniu zmian: zastosowanie domyślnej inicjalizacji niestatycznych składowych struktury.}, 
    label={lst:init_after}
]{5_code/code_samples/init_after.cpp}

Zaprezentowane do tej pory zmiany stanowią oczywiście jedynie wybrany podzbiór wykonanych przez autorów modyfikacji. Poza do tej pory opisanymi, wykonane zostały inne przekształcenia mające na celu migrację kodu źródłowego do standardu C++11, m.in.:
\begin{itemize}
    \item zastosowanie słowa kluczowego \lstinline{override} w~celu jawnego zadeklarowania, że metoda znajdująca się w~klasie pochodnej przeciąża metodę z~klasy bazowej - pozwala to wykrywać na etapie kompilacji błędy związane z~nieprawidłową implementacją polimorfizmu, takie jak zmiana sygnatury metody w~klasie bazowej przy jednoczesnym niewykonaniu tej czynności w~klasie pochodnej
    \item zastosowanie słowa kluczowego \lstinline{final} w~celu zabronienia dziedziczenia lub przeciążania metod w~przypadku modułów, które nie były projektowane z~myślą o~polimorfizmie
    \item zastąpienie opartej o~pakiet Boost (m.in. \lstinline{boost::assign}) inicjalizacji kontenerów wchodzących w~skład biblioteki standardowej za pomocą rozwiązań oferowanych przez standard C++11 (jednolita inicjalizacja i~konstruktory oparte o~\lstinline{std::initializer_list})
    \item zastąpienie, tam gdzie było to możliwe, znanych z~języka C~tablic za pomocą kontenera \lstinline{std::array}
    \item zastąpienie przygotowanych na potrzeby systemu GGSS funkcji, takich jak wykonująca konwersję typu liczbowego do łańcucha znaków funkcja pomocnicza \lstinline{toString}, za pomocą rozwiązań standardowych (np. \lstinline{std::to_string})
    \item zastosowanie semantyki przenoszenia i~referencji do r-wartości
    \item zastąpienie słowa kluczowego \lstinline{typedef} za pomocą słowa \lstinline{using}
\end{itemize}

\subsection{Naprawa błędów w~kodzie źródłowym}
Kod źródłowych wchodzący w~skład warstwy oprogramowania systemu GGSS od początku prac charakteryzował się bardzo wysoką poprawnością - zawierał tak naprawdę jedynie niewielką liczbę niezagrażających działaniu systemu niedociągnięć. Celem autorów była poprawa działania tych fragmentów kodu, w~których udało się zlokalizować wszelkiego typu niedoskonałości. 

Przeważająca część znajdowanych przez autorów, zarówno podczas oględzin kodu, jak i~testów systemu w~środowisku docelowym, błędów dotyczyła nietypowych scenariuszy, nie mających miejsca w~czasie regularnego działania projektu. Bardzo często odnajdywane niedoskonałości związane były ze stosowanym w~projekcie mechanizmem wielowątkowości - ich naprawa sprowadzała się zwykle do przeprowadzenia szczegółowych testów mających na celu identyfikację przyczyny i~dokładnego miejsca występowania problemu oraz wprowadzenia niewielkiej poprawki (np. poprzez wykorzystanie dodatkowej zmiennej pomocniczej lub instrukcji warunkowej) w~odpowiednim miejscu kodu źródłowego. Jednym z~przykładów tego typu błędów była sytuacja, w~której użytkownik próbował zmienić kolejność, w~jakiej dokonywany jest pomiar za pomocą poszczególnych liczników słomkowych, w~trakcie trwania takiego pomiaru. W~odpowiednich warunkach mogło to doprowadzić do sytuacji, w~której zebrane dane przypisywane były do nieprawidłowego licznika. Dla przykładu, jeśli system skonfigurowany był w~taki sposób, że pomiary dokonywane były kolejno dla kanałów o~numerach \lstinline{0:1,0:3,0:6,0:2}, a~użytkownik, podczas pomiaru na kanale \lstinline{0:3} dokonał zmiany kolejności na \lstinline{0:1,0:4,0:5,0:2}, to wynik pomiaru wykonanego za pomocą licznika \lstinline{0:3} przypisywany był licznikowi o~numerze \lstinline{0:4}. Ponieważ rozwiązywanie tego typu problemów wymagało przede wszystkim znajomości trudnych do przedstawienia w~pracy magisterskiej detali dotyczących implementacji poszczególnych funkcjonalności systemu GGSS, autorzy zdecydowali się nie prezentować w~niniejszym manuskrypcie szczegółów postępowania w~tego typu przypadkach.

Zadaniem autorów było ponadto diagnozowanie i~naprawianie usterek związanych z~niepoprawną implementacją algorytmów wchodzących w~skład projektu. Podczas prac nad kodem źródłowym aplikacji \emph{ggss-runner} zidentyfikowany został jeden tego typu problem, związany z~działaniem odpowiedzialnej za przetwarzanie plików konfiguracyjnych systemu GGSS biblioteki \emph{xml-lib}. Dokument XML interpretować można jako drzewo, co oznacza, że poszczególne jego elementy tworzą strukturę hierarchiczną - element nadrzędny zawiera w~sobie potomne. Z~punktu widzenia omawianego problemu istotne jest rozróżnienie pomiędzy pojęciem \emph{potomka} (ang. \emph{descendant}), a~\emph{dziecka} (ang. \emph{child}). Na rysunku \ref{fig:xml_example} przedstawione zostało proste drzewo mogące stanowić interpretację dokumentu XML. Potomkami są wszystkie węzły zawarte w~ramach danego elementu (nie tylko bezpośrednio), co zostało zobrazowane na rysunku \ref{fig:xml_descendant}, gdzie kolorem zielonym oznaczeni zostali potomkowie elementu \emph{A}. Pojęciem dziecka określany jest natomiast węzeł zawarty bezpośrednio w~innym elemencie - na rysunku \ref{fig:xml:children} kolorem zielonym oznaczone zostały dzieci elementu \emph{A}. Zadaniem analizowanego fragmentu kodu było wyszukiwanie w~strukturze XML węzła o~zadanej nazwie, zawierającego atrybut \lstinline{id} o~zadanej wartości. Punktem wyjścia poszukiwania był inny, przekazywany do funkcji węzeł. W~swojej pierwotnej postaci algorytm dokonywał sprawdzenia wszystkich potomków elementu wyjściowego, jednakże, z~powodu błędu w~implementacji, przy zwracaniu wyniku pod uwagę brane były jedynie węzły stanowiące dzieci przekazanego do funkcji węzła. Ta nieprawidłowość wykryta została przez autorów podczas przygotowywania testów jednostkowych, mających stanowić zabezpieczenie poprawności kodu podczas prac nad innymi fragmentami biblioteki \emph{xml-lib}. Błąd ten nie miał negatywnego wpływu na działanie systemu GGSS, co wynikało ze specyficznej budowy przetwarzanego za jego pomocą pliku konfiguracyjnego. 

\begin{figure}[H]
\centering

\begin{subfigure}{0.48\textwidth}
\centering
\includegraphics[width=\textwidth]{xml_descendants.pdf}
\caption{Kolorem zielonym oznaczono potomków węzła A.}
\label{fig:xml_descendant}
\end{subfigure}
\begin{subfigure}{0.48\textwidth}
\centering
\includegraphics[width=\textwidth]{xml_children.pdf}
\caption{Kolorem zielonym oznaczono dzieci węzła A.}
\label{fig:xml:children}
\end{subfigure}

\caption{Przykładowe drzewo mogące stanowić interpretację dokumentu XML. Przykład obrazuje różnicę pomiędzy pojęciem potomka, a~dziecka w~rozumieniu struktury XML. }
\label{fig:xml_example}
\end{figure}

Analizowany fragment kodu, w~swojej pierwotnej postaci, przedstawiony został na listingu \ref{lst:xml_before}. Błąd wynika z~faktu, iż rezultat rekurencyjnego wywołania funkcji \lstinline{m_findTagById} nie jest przypisywany do żadnej zmiennej - wyszukiwanie ma miejsce, natomiast jego wynik nie jest brany pod uwagę. Możliwe były dwa sposoby poprawy tej nieprawidłowości: usunięcie rekurencyjnego przeszukiwania lub dodanie przetwarzania zwróconych przez nie węzłów. Autorzy zdecydowali się na wybór pierwszej możliwości - dzięki temu zwiększona została czytelność kodu, jednocześnie nie wprowadzając zmian w~sposobie jego działania widzianym z~perspektywy użytkownika. Wynikowy kod przedstawiony została na listingu \ref{lst:xml_after}.

\lstinputlisting[
    language=C++, 
    caption={Wadliwy fragment kodu, implementujący wyszukiwanie w~strukturze XML węzła o~zadanej nazwie i~wartości atrybutu \lstinline{id}.}, 
    label={lst:xml_before}
]{5_code/code_samples/xml_before.cpp}

\lstinputlisting[
    language=C++, 
    caption={Fragment kodu implementujący wyszukiwanie w~strukturze XML węzła o~zadanej nazwie i~wartości atrybutu \lstinline{id} po wprowadzeniu przez autorów poprawek. Wyeliminowane zostało rekurencyjne wywołanie funkcji oraz przeprowadzona została migracja kodu do standardu C++11.}, 
    label={lst:xml_after}
]{5_code/code_samples/xml_after.cpp}


\subsection{Likwidacja nieużywanych fragmentów kodu źródłowego}
Podczas prac na kodem autorzy zidentyfikowali i~usunęli jego niewykorzystywane fragmenty, stanowiące bardzo często pozostałości po wcześniejszych wersjach systemu. Wprowadzone zmiany obejmowały zarówno pojedyncze zmienne i~wyrażenia, jak również całe funkcje oraz klasy. 

Przykładem zlikwidowanego kodu jest zamieszczony na listingu \ref{lst:mutable_pair} szablon struktury \lstinline{mutable_pair} pochodzący z~biblioteki \emph{xml-lib}. Jego działanie jest bardzo podobne do znanego z~biblioteki standardowej języka C++ szablonu \lstinline{std::pair}, jednakże zaprezentowana konstrukcja wzbogacona została ponadto o~słowo kluczowe \lstinline{mutable}, wykorzystywane w~celu umożliwienia edycji pola \lstinline{second} nawet, jeśli utworzony za pomocą wygenerowanej struktury obiekt oznaczony byłby jako niemodyfikowalny. W~rzeczywistości jednak funkcjonalność ta nie była wykorzystywana w~projekcie - nie zachodził przypadek, w~którym podejmowana była próba modyfikacji obiektu oznaczonego słowem kluczowym \lstinline{const}. Dlatego też zaprezentowany szablon struktury został usunięty a~jego użycia zastąpione przez \lstinline{std::pair}.

\lstinputlisting[
    language=C++, 
    caption={Zlikwidowany szablon struktury \lstinline{mutable_pair}, znajdujący się pierwotnie w~bibliotece \emph{xml-lib}. Działanie szablonu przypomina konstrukcję \lstinline{std::pair} znaną z~biblioteki standardowej języka C++, jednakże z~dodanym wykorzystaniem słowa kluczowego \lstinline{mutable} w~przypadku drugiego z~pól.}, 
    label={lst:mutable_pair}
]{5_code/code_samples/mutable_pair.cpp}


Inny przykład stanowić mogą metody wchodzące w~skład szablonu klasy \lstinline{QueueLimited}, odpowiedzialnej za implementację kolejki o~ograniczonym rozmiarze. Szablon ten wykorzystuje do przechowywania danych kontener sekwencyjny \lstinline{std::deque}. Przykład usuniętej metody zaprezentowany został na listingu \ref{lst:queue_deleted_code} - stanowiła ona prawdopodobnie mechanizm pozwalający na łatwe sprawdzenie działania zaimplementowanego szablonu. Jednakże w~obecnej wersji projektu nie jest ona wykorzystywana. Jej sposób działania jest ponadto niebezpieczny z~punktu widzenia poprawności działania aplikacji - zwraca ona przez referencję kontener wykorzystywany do zaimplementowania wspomnianej kolejki o~ograniczonym rozmiarze. Taki dostęp umożliwia użytkownikowi modyfikację zawartości kolejki z~pominięciem zaprojektowanych w~tym celu metod, zawierających m.in. odpowiednie sprawdzenia dotyczące rozmiaru struktury. Nieprawidłowe stosowanie zaprezentowanej funkcji mogłoby zatem łatwo doprowadzić do sytuacji, w~której działanie kolejki staje się nieprzewidywalne. 

\lstinputlisting[
    language=C++, 
    caption={Przykład usuniętej metody, łamiącej jedną z~podstawowych zasad programowania obiektowego: hermetyzację. Zaprezentowany fragment pochodzi z~biblioteki \emph{fifo-lib}.}, 
    label={lst:queue_deleted_code}
]{5_code/code_samples/queue_deleted_code.cpp}

Likwidacji poddane zostały ponadto fragmenty kodu zawarte w~bibliotece \emph{ggss-lib}, które przestały być używane z~uwagi na zmiany w~sposobie działania projektu GGSS jako całości. We wcześniejszych wersjach systemu zarządzanie wartościami napięcia oraz natężenia prądu odbywało się z~wykorzystaniem specjalnego urządzania, tzw. ELMB. W~aktualnym wydaniu projektu nie ma to natomiast miejsca - w~tym celu wykorzystywane są biblioteki do obsługi zasilaczy wysokiego napięcia. Dlatego też fragmenty kodu odpowiedzialne za implementację przestarzałej wersji mechanizmu zostały zlikwidowane.

Poza do tej pory wymienionymi, autorzy dokonali szeregu innych zmian mających na celu likwidację nieużywanych fragmentów kodu źródłowego. Należały do nich m.in.: likwidacja niewywoływanych nigdy funkcji \lstinline{pochisq}, \lstinline{critchi} oraz \lstinline{poz} z~biblioteki \emph{fit-lib} czy też uproszczenie interfejsu biblioteki \emph{xml-lib}, która w~swojej pierwotnej wersji udostępniała do trzech, różniących się sposobem przekazywania parametrów do funkcji, wersji jednej funkcjonalności.


\subsection{Pozostałe zmiany i~podsumowanie}
W~ramach niniejszej pracy wykonane zostały ponadto zmiany w~kodzie takie jak: wyodrębnienie do funkcji wielokrotnie powtarzających się fragmentów kodu, zmiana w~strukturze bibliotek składających się oryginalnie z~pojedynczego pliku (rozbicie na mniejsze pliki), ujednolicenie konwencji nazewnictwa i~formatowania (w tym dokumentacji) oraz usunięcie zawartych w~komentarzach fragmentów kodu.

Zmianie uległo formatowanie kodu, które w~swojej oryginalnej wersji było bardzo niespójne, co zaprezentowane zostało na rysunku \ref{fig:format_problem}. We wszystkich tego typu przypadkach autorzy wprowadzili zmiany: zastosowana została jednolita konwencja, co umożliwiło uczynienie kodu bardziej przystępnym dla programisty. W~podobny sposób ujednolicone zostały komentarze mające stanowić dokumentację poszczególnych klas czy funkcji.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{format_problem.png}
\caption{Zrzut ekranu przedstawiający fragment kodu źródłowego pochodzącego z~pierwotnej wersji biblioteki \emph{ggss-lib}. Zachowane zostało oryginalne formatowanie kodu. Zaprezentowany fragment charakteryzuje się niespójnością pod względem użytych wcięć oraz nazewnictwa, jak również obecnością komentarzy zawierających nieużywany kod.}
\label{fig:format_problem}
\end{figure}

Biblioteka \emph{log-lib} zawierała pierwotnie jeden plik nagłówkowy \lstinline{Logger.h}, zawierający informacje dotyczące zarówno sposobu implementacji biblioteki, jak i~jej oczekiwanego interfejsu (zestaw makr). Aby ułatwić korzystanie z~niej, zawartość wspomnianego pliku przeniesiona została do trzech plików: \lstinline{GgssLog.h}, \lstinline{Logger.h} oraz \lstinline{SeverityLevel.h} - każdy z~nich zawiera informacje na temat innego aspektu działania biblioteki, a~ponadto jedynie plik \lstinline{GgssLog.h} przeznaczony jest to użytku poza nią. Analogicznie podzielona została zawartość pliku \lstinline{.cpp} wchodzącego w~skład biblioteki. Podobnego typu zmiany przeprowadzone zostały w~przypadku modułu \emph{sigslot-lib}.

Podsumowując, autorzy dokonali znaczących zmian w~kodzie źródłowym projektu, których celem było zwiększenie jego szeroko rozumianej jakości. Modyfikacjom na szeroką skalę poddane zostało 12 z~14 bibliotek wchodzących oryginalnie w~skład systemu. W~przypadku pozostałych dwóch (\emph{daemon-lib} oraz \emph{thread-lib}) ograniczono się natomiast jedynie do ujednolicenia formatowania.

\clearpage
\section{Rozszerzenie możliwości aplikacji}
Zadaniem autorów, poza poprawą działania i~jakości systemu GGSS, było wzbogacenie go o~nowe funkcjonalności. W~tej części pracy przedstawiony został szczegółowy opis najważniejszych rozszerzeń wprowadzonych przez autorów do aplikacji \emph{ggss-runner}. 

\subsection{Obsługa zaawansowanych komend dla zasilaczy wysokiego napięcia} \label{ch:hv}
Jednym z~zadań systemu GGSS jest komunikacja z~zasilaczami wysokiego napięcia w~celu monitorowania oraz modyfikacji ich parametrów. W~swojej aktualnej postaci projekt wykorzystuje trzy czterokanałowe zasilacze CAEN N1470, których zadaniem jest dostarczanie zasilana do słomkowych liczników proporcjonalnych. Urządzenia podłączone są do głównego komputera łańcuchowo (ang. \emph{daisy chain}), tzn. pierwszy zasilacz podłączony jest do niego bezpośrednio, a~każdy kolejny łączony jest z~poprzednim (rys. \ref{fig:psu0}). Komunikacja z~urządzeniami odbywa się poprzez port szeregowy, za pomocą specjalnych komend, których składnia określona została przez producenta. 

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{hv_psu_0.pdf}
\caption{Łańcuchowe połączenie trzech czterokanałowych zasilaczy wysokiego napięcia z~komputerem. Za pomocą kwadratów z~oznaczeniem \lstinline{CH<N>} przedstawiono kanały każdego z~urządzeń. Nazwy poszczególnych modułów zostały, na potrzeby przykładu, uproszczone względem tych stosowanych w~systemie GGSS.}
\label{fig:psu0}
\end{figure}

Dostarczone przez producenta zasilaczy komendy sterujące pozwalają zarówno na monitorowanie (MON), jak i~modyfikację (SET) parametrów urządzeń, takich jak oczekiwana wartość napięcia. Poza wykonywaną operacją, komendy różnią się od siebie ponadto zakresem działania - mogą dotyczyć poszczególnych kanałów (np. modyfikacja maksymalnej dopuszczalnej wartości napięcia) lub modułu jako całości (np. pobranie jego numeru seryjnego). Przykładowo, format komendy monitorującej wartość określonego parametru dla pojedynczego kanału zdefiniowany został przez producenta w~następujący sposób: \lstinline{$BD:<moduł>,CMD:MON,CH:<kanał>,PAR:<parametr>}. Dostępne polecenia pozwalają wykonywać operacje tylko ja jednym module jednocześnie, możliwy jest natomiast wybór pomiędzy jednym kanałem, a~wszystkimi (specjalna wartość 4). System GGSS w~swojej pierwotnej wersji oferował obsługę tego typu komend, stanowiąc pośrednika między użytkownikiem a~urządzeniami.

Stosowanie tego typu poleceń charakteryzuje się, z~punktu widzenia użytkownika, pewnymi niedogodnościami, z~czego najważniejsze to: brak możliwości operowania na kilku zasilaczach jednocześnie oraz trudna do zapamiętania, nieintuicyjna składnia. Zadaniem autorów było przygotowanie biblioteki udostępniającej alternatywny, przyjazny użytkownikowi, zestaw komend, który byłby następnie tłumaczony przez system GGSS na format zdefiniowany przez producenta urządzeń. 

W~przypadku komend monitorujących parametry na poziomie poszczególnych kanałów przygotowany został następujący format: \lstinline{hv <moduł>:<kanał> mon <parametr[,inne_parametry]>}, przy czym możliwe jest zastosowanie znaku \lstinline{*} w~zamian za specyfikację modułu lub kanału, co oznacza \emph{wszystkie moduły/kanały}. Ponadto, dodatkowym ulepszeniem w~stosunku do oryginalnej składni jest możliwość monitorowania wartości kilku parametrów jednocześnie - w~takim wypadku należy przedzielić je przecinkiem. Przykładem nowego polecenia jest \lstinline{hv *:2 mon vmon}, które pozwala na monitorowanie napięcia (parametr \lstinline{vmon}) na kanale numer 2~dla każdego z~zasilaczy (rys. \ref{fig:psu1}). To polecenie jest odpowiednikiem wykonania trzech, zgodnych z~oryginalna składnią, komend (po jednej dla każdego modułu):
\begin{lstlisting}
$BD:0,CMD:MON,CH:2,PAR:VMON
$BD:1,CMD:MON,CH:2,PAR:VMON
$BD:2,CMD:MON,CH:2,PAR:VMON
\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{hv_psu_1.pdf}
\caption{Zasada działania komendy typu \lstinline{hv *:2 mon <parametry>} - kolorem zielonym oznaczone zostały te kanały zasilaczy, z~których pobrana zostanie monitorowana wartość. W~tym przypadku jest to kanał numer 2~w każdym z~urządzeń.}
\label{fig:psu1}
\end{figure}

Odpowiedź otrzymana od urządzeń formatowana jest w~taki sposób, by możliwe było stosunkowo łatwe jej parsowanie (np. w~celu tworzenia skryptów). Przykładowy wynik działania dla zaprezentowanej wyżej komendy prezentuje się następująco:
\begin{lstlisting}
OK: caen_0:2:VMON:1364.8;caen_1:2:VMON:0.0;caen_2:2:VMON:0.0
\end{lstlisting}

Innym przykładem wspieranej komendy jest \lstinline{hv caen_1:* mon vmon} - dokonuje ona sprawdzenia wartości napięcia na wszystkich kanałach zasilacza oznaczonego nazwą \lstinline{caen_1}. Jej odpowiednikiem zapisanym za pomocą składni dostarczonej przez producenta byłoby polecenie \lstinline{$BD:1,CMD:MON,CH:4,PAR:VMON} - wartość 4~pełni tutaj rolę wartości specjalnej, odnoszącej się do wszystkich kanałów. Autorzy zdecydowali się jednak nie stosować tej konwencji (zastępując wartość 4~znakiem \lstinline{*}), ponieważ dla osoby nieznającej szczegółów działania zasilaczy CAEN N1470 mogłaby być ona myląca, a~ponadto tworzyłaby ona powiązanie pomiędzy ilością kanałów w~zasilaczu, a~logiką biblioteki implementującej obsługę komend. Zasada działania powyższej komendy zaprezentowana została w~formie graficznej na rysunku \ref{fig:psu2}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{hv_psu_2.pdf}
\caption{Zasada działania komendy typu \lstinline{hv caen_1:* mon <parametry>} - kolorem zielonym oznaczone zostały te kanały zasilaczy, z~których pobrana zostanie monitorowana wartość. W~tym przypadku są to wszystkie kanały urządzenia o~nazwie \lstinline{caen_1}.}
\label{fig:psu2}
\end{figure}

Zadaniem przygotowanych komend jest ułatwienie użytkownikowi prowadzenia interakcji z~zasilaczami wysokiego napięcia za pośrednictwem systemu GGSS. Ich stosowanie pozwala, za pomocą jednego polecenia, wykonać zapytanie wymagające wcześniej zastosowania większej liczby komend. Np. komenda \lstinline{hv *:* mon vset,vmon,iset}, dokonująca sprawdzenia wartości trzech różnych parametrów dla każdego kanału we wszystkich urządzaniach, odpowiada wykonaniu dziewięciu poleceń za pomocą składni dostarczonej przez producenta:
\begin{lstlisting}
$BD:0,CMD:MON,CH:4,PAR:VMON
$BD:1,CMD:MON,CH:4,PAR:VMON
$BD:2,CMD:MON,CH:4,PAR:VMON
$BD:0,CMD:MON,CH:4,PAR:VSET
$BD:1,CMD:MON,CH:4,PAR:VSET
$BD:2,CMD:MON,CH:4,PAR:VSET
$BD:0,CMD:MON,CH:4,PAR:ISET
$BD:1,CMD:MON,CH:4,PAR:ISET
$BD:2,CMD:MON,CH:4,PAR:ISET
\end{lstlisting}

W~podobny sposób przygotowana została składnia komend wykonujących operacje na poziomie pojedynczego modułu - użytkownik pomija jedynie informację o~wybranych kanałach. Tego typu komendy pozwalają uzyskiwać informacje takie jak nazwa modułu czy też jego numer seryjny. Przykładem polecenia operującego na poziomie zasilaczy jest \lstinline{hv * mon bdname} pobierające nazwy wszystkich trzech modułów - jego zasada działania zilustrowana została na rysunku \ref{fig:psu3}. Jest to odpowiednik wykonania trzech komend za pomocą składni dostarczonej przez producenta (po jednej dla każdego urządzenia).

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{hv_psu_3.pdf}
\caption{Zasada działania komendy typu \lstinline{hv * mon <parametry>}, tzn. operującej na poziomie modułów. Kolorem zielonym oznaczone zostały te zasilacze, z~których pobrana zostanie monitorowana wartość - w~tym przypadku, ze względu na wykorzystanie znaku \lstinline{*}, są to wszystkie dostępne moduły.}
\label{fig:psu3}
\end{figure}

Autorzy przygotowali ponadto komendy typu SET, pozwalające na modyfikowanie wartości parametrów, zarówno na poziomie pojedynczych kanałów, jak i~zasilaczy. Ich zasada działania jest bardzo podobna do komend monitorujących, z~kilkoma różnicami:
\begin{itemize}
    \item użytkownik po nazwie parametru specyfikuje jego oczekiwaną wartość
    \item nie ma możliwość wykonywania komendy dla kilku parametrów jednocześnie
\end{itemize}
Przykładem tego typu polecenia, wykonującego operację zmiany wartości napięcia na każdym kanale zasilacza \lstinline{caen_0} na wartość 0, jest komenda \lstinline{hv caen_0:* set vset 0}. Sposób określania wykorzystywanych zasilaczy i~kanałów jest identyczny do tego stosowanego w~przypadku komend typu MON. Szczególnym przypadkiem komend typu SET są komendy typu \lstinline{hv <moduł>:<kanał> set ON/OFF}, których zadaniem jest włączenie lub wyłączenie danego kanału - w~ich przypadku użytkownik nie specyfikuje wartości.

W~celu zachowania możliwości wykorzystywania składni przygotowanej przez producenta zasilaczy, wprowadzony został trzeci typ polecenia, oznaczany za pomocą słowa RAW. Składnia tego typu poleceń jest następująca: \lstinline{hv <moduł> raw <polecenie>}, gdzie \lstinline{<polecenie>} oznacza komendę zgodną z~oryginalną składnią. Przykładem komendy typu RAW jest polecenie \lstinline{hv caen_0 raw $BD:00,CMD:MON,CH:0,PAR:VMON}, monitorujące wartość napięcia na kanale numer 0~urządzania o~nazwie \lstinline{caen_0}. Komendy te pozwalają operować jednocześnie jedynie na jednym urządzeniu - wynika to z~faktu, iż specyfikacja \lstinline{<moduł>} musi być zgodna z~numerem zawartym w~ciele komendy.

Z~punktu widzenia implementacji zaprezentowana funkcjonalność przygotowana została w~formie, znajdującej się w~repozytorium \emph{ggss-hardware-libs}, biblioteki statycznej \emph{hvcommand-lib}. Zawarty w~niej kod przygotowany został zgodnie ze standardem C++11 i~oparty został o~polimorficzną hierarchię klas reprezentujących parsery, z~których każdy przystosowany został do przetwarzania innego typu komend: MON, SET lub RAW (rys. \ref{fig:psu_parsers}). Odpowiednia implementacja wybierana jest na podstawie trzeciego elementu każdej z~komend (podział na elementy za pomocą białych znaków) - służy do tego klasa \lstinline{HighVoltageCommandParserFactory}. Następnie parser przekształca otrzymaną komendę do zbioru obiektów reprezentujących czynności wykonywane na urządzeniach - kontener ten określony jest w~kodzie źródłowym nazwą \lstinline{HighVoltageCommandQueue}. W~kolejnym kroku poszczególne akcje są wykonywane, a~wynik jest przekształcany do odpowiedniego formatu.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{parsers.pdf}
\caption{Diagram klas obrazujący architekturę przygotowanej biblioteki: główną część stanowi oparta o~polimorfizm hierarchia klas służących do przekształcania komend do zbioru obiektów reprezentujących czynności wykonywane na urządzeniach. }
\label{fig:psu_parsers}
\end{figure}

Obiekty reprezentujące poszczególne czynności wykonywane na urządzeniach, przechowywane w~zapełnianym przez parsery kontenerze \lstinline{HighVoltageCommandQueue}, również modelowane są przez polimorficzną hierarchię klas (rys. \ref{fig:psu_commands}). Poszczególne klasy dziedziczące po abstrakcji \lstinline{HighVoltageCommand} odpowiadają za: czynności wykonywane na pojedynczym urządzeniu, pojedynczym kanale oraz komendy typu RAW.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{commands.pdf}
\caption{Diagram klas obrazujący hierarchię reprezentującą czynności wykonywane na urządzeniach.}
\label{fig:psu_commands}
\end{figure}

Dla biblioteki przygotowane zostały testy jednostkowe, pozwalające na automatyczną weryfikację poprawności implementacji. Ponadto przygotowane komendy były wielokrotnie testowane w~środowisku produkcyjnym (co jest szczególnie istotne z~uwagi na ich ścisły związek z~urządzeniami), co zostało opisane w~części pracy poświęconej testom projektu.

\subsection{Rozbudowa biblioteki odpowiedzialnej za dopasowywanie krzywej}
Biblioteka \emph{fit-lib}, zawierająca implementację algorytmów dopasowujących krzywą do zebranych danych, została przebudowana przez autorów w~ramach niniejszej pracy. Wprowadzone zostały następujące zmiany:
\begin{itemize}
    \item zmiana architektury opartej o~rozbudowaną hierarchię dziedziczenia na prostszą, opartą o~kompozycję i~wstrzykiwanie zależności
    \item dodanie obsługi dodatkowych kombinacji parametrów początkowych dopasowania
    \item przebudowa mechanizmu wyznaczającego jeden z~parametrów początkowych algorytmu dopasowania: maksimum lokalne 
\end{itemize}

Pierwotna wersja architektury biblioteki przedstawiona została w~uproszczeniu na rysunku \ref{fig:fit_old}. Kolorem zielonym oznaczona została klasa abstrakcyjna, fioletowym zaś - klasy, za pomocą których możliwe było utworzenie obiektu. Kolorem czerwonym oznaczono nieistniejące w~bibliotece oryginalnie klasy, które byłyby konieczne do dodania w~ramach jej planowanej rozbudowy. Każda konkretna klasa reprezentować miała odmienny rodzaj algorytmu przeprowadzającego dopasowanie funkcji do zebranych danych. Jak zatem widać, struktura biblioteki oparta była o~wielopoziomową hierarchię dziedziczenia. Klasy o~nazwach zakończonych przyrostkiem \lstinline{Xe} oraz \lstinline{Ar} różniły się od swoich odpowiedników bez niego jedynie parametrami początkowymi, jakie stosowane były w~algorytmie przeprowadzającym dopasowanie funkcji - dla klas bez przyrostka parametrom tym przypisana była wartość 0. Obrazuje to pierwszy problem związany z~takim projektem biblioteki - pomimo, ze możliwe było stworzenie obiektów za pomocą klas \lstinline{GaussFit} oraz \lstinline{Gauss2Fit}, to ich istnienie nie miało uzasadnienia z~punktu widzenia logiki aplikacji, ponieważ przeprowadzają one dopasowanie z~wyzerowanymi parametrami początkowymi - możliwe było wprowadzenie programu w~niepoprawny stan. Drugi problem wynikał z~konieczności rozbudowania biblioteki o~dwie nowe, różniące się jedynie kilkoma wartościami pól, klasy: \lstinline{GaussFitAr} oraz \lstinline{Gauss2FitAr}, by wspierać inne zestawy parametrów początkowych. Aby uniknąć takiego scenariusza autorzy zdecydowali się przebudować bibliotekę.


\begin{figure}[H]
\centering
\includegraphics[width=0.60\textwidth]{fit_old.pdf}
\caption{Pierwotna wersja architektury biblioteki \emph{fit-lib}. Kolorem zielonym oznaczono klasę abstrakcyjną, kolorem filetowym - jej konkretne implementacje. Kolorem czerwonym oznaczono komponenty konieczne do dodania w~ramach rozbudowy biblioteki. Zaprezentowane rozwiązanie charakteryzuje się szeregiem wad utrudniających łatwe rozwijanie biblioteki o~nowe zestawy parametrów początkowych.}
\label{fig:fit_old}
\end{figure}

Biblioteka implementowała dwie możliwości dopasowywania krzywej: dla rozkładów jednomodalnych (klasa \lstinline{GaussFit} i~jej pochodne) i~dwumodalnych (klasa \lstinline{Gauss2Fit} i~jej pochodne). Poszczególne klasy pochodne miały różnić się od siebie i~od klasy bazowej jedynie parametrami początkowymi dopasowania. Z~tego też powodu tworzenie rozbudowanej hierarchii dziedziczenia, gdzie poszczególne klasy pochodne różnią się od siebie wartościami kilku parametrów, wydawało się autorom nieuzasadnione. Przebudowa biblioteki polegała na uproszczeniu hierarchii w~taki sposób, by składała się ona jedynie z~trzech klas: abstrakcyjnej \lstinline{Fit} oraz konkretnych \lstinline{GaussFit} oraz \lstinline{Gauss2Fit}. Parametry początkowe dopasowania są natomiast w~nowej wersji wstrzykiwane przez konstruktor do obiektów klas pochodnych, a~konkretniej - wstrzykiwana jest funkcja powodująca ich ustawienie przed wykonaniem dopasowania. Przykład tego typu funkcji zaprezentowany został na listingu \ref{lst:fit_initializer}. W~swojej nowej wersji biblioteka wykorzystuje funkcjonalności oferowane przez standard C++11, w~tym szablon \lstinline{std::function} oraz inteligentny wskaźnik \lstinline{std::unique_ptr}.

\lstinputlisting[
    language=C++, 
    caption={Przykład stworzonej przez autorów funkcji przeprowadzającej inicjalizację parametrów początkowych dopasowania krzywej do danych. W~tym przypadku są to parametry dla rozkładu jednomodalnego, w~wersji dla argonu (tzn. jest to alternatywa dla klasy \lstinline{GaussFitAr}).}, 
    label={lst:fit_initializer}
]{5_code/code_samples/fit_initializer.cpp}

Algorytmy przeprowadzające dopasowanie krzywej do zebranych danych nie zostały przez autorów zmodyfikowane, dlatego też w~niniejszej pracy nie został zawarty opis ich działania. na rysunku \ref{fig:fit_example_good_1} przedstawiony został natomiast zrzut ekranu zawierający fragment panelu dostępnego w~ramach systemu WinCC OA - zaprezentowane zostało na nim poprawne działanie algorytmu w~przypadku dopasowania dla rozkładu jednomodalnego. Na załączonym zrzucie ekranu zaobserwować można m.in. wykres przedstawiający zebrane dane wraz z~dopasowaną funkcją (oznaczoną kolorem niebieskim), wzór dopasowywanej krzywej oraz właściwości zebranego widma.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{gaussfitxe.png}
\caption{Fragment panelu dostępnego w~ramach systemu WinCC OA, przedstawiający poprawne działanie algorytmu dopasowującego krzywą do zebranych danych (rozkład jednomodalny). Poza wykresem widoczne są elementy takie jak wzór dopasowanej funkcji oraz właściwości zebranego widma, w~tym położenie maksimum lokalnego.}
\label{fig:fit_example_good_1}
\end{figure}


Jednym z~parametrów początkowych przeprowadzanego dopasowania jest umiejscowienie maksimum lokalnego, oznaczane w~kodzie nazwą \lstinline{pp0} (w przypadku rozkładu dwumodalnego wyznaczane jest również na jego podstawie położenie drugiego maksimum, oznaczane jako \lstinline{pp1}). W~oryginalnej wersji algorytm jego znajdowania był stosunkowo prymitywny: polegał na iteracji po dziedzinie funkcji za pomocą okna o~danej szerokości i~poszukiwaniu takiego umiejscowienia, gdzie pole pod wykresem jest największe. Algorytm ten pozwalał na wykrycie jedynie jednego ekstremum, nie sprawdzał się więc dobrze w~sytuacjach, w~których analizowane dane charakteryzowały się wysokim poziomem zaszumienia - przykład tego typu sytuacji, powodujący w~oryginalnej wersji aplikacji \emph{ggss-runner} błąd, przedstawiony został na rysunku \ref{fig:spectrum_error}.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{spectrum_error.png}
\caption{Przykład zebranych przez aplikację \emph{ggss-runner} danych. Ich znaczące zaszumienie spowodowało uformowanie się nieoczekiwanego ekstremum lokalnego na przedziale $[90, 150]$. W~pierwotnej wersji aplikacji tego typu dane powodowały błąd (co jest widoczne na rysunku), ponieważ algorytm poszukujący maksimum lokalnego znajdował je właśnie w~tym przedziale, nie zaś, zgodnie z~oczekiwaniami, na przedziale $[450, 550]$.}
\label{fig:spectrum_error}
\end{figure}

Z~tego też powodu konieczne było zaimplementowanie nowego algorytmu poszukującego maksimum lokalnego. Autorzy oparli swoje rozwiązanie o~dwie funkcjonalności: 
\begin{itemize}
    \item przeprowadzanie poszukiwań tylko na określonym przez użytkownika przedziale (tzw. \emph{fit range}) - możliwy jest taki jego dobór, by nie zawierał w~sobie drugiego, nieporządnego maksimum lokalnego
    \item przeprowadzenie tzw. wygładzenia danych (ang. \emph{smoothing}), mającego na celu eliminację szumów oraz zastosowanie bardziej rozbudowanego algorytmu poszukującego maksimum
\end{itemize}

Implementacja poszukiwania na określonym przedziale była stosunkowo prosta, ponieważ w~systemie istniały już parametry \lstinline{fitLowerBound} oraz \lstinline{fitUpperBound}, wykorzystywane bezpośrednio przez algorytm dopasowujący krzywą (ale nie przez algorytm poszukujący ekstremum). Zadaniem autorów było zatem jedynie ograniczenie przedziału poszukiwania maksimum lokalnego za pomocą tych parametrów. Ich modyfikacja możliwa jest z~poziomu pliku konfiguracyjnego systemu GGSS lub poprzez wysłanie komendy za pośrednictwem interfejsu DIM. Rozwiązanie to okazało się wystarczające, by zaprezentowany powyżej błąd został naprawiony - dobór odpowiedniego zakresu, na którym przeprowadzane jest poszukiwanie pozwolił uniknąć sytuacji, w~której znajdowane było ekstremum powstałe na skutek działania szumów. 

Nowy algorytm poszukiwania maksimum lokalnego działa w~sposób dwuetapowy. Najpierw tworzona jest kopia zebranych danych, która poddawana jest na, w~celu początkowej redukcji zaszumienia, działaniu symetrycznego filtru średniej ruchomej (ang. \emph{moving average filter}) \cite{smoothing}, danego następującym wzorem:
\begin{equation}
y_f(i) = \frac{1}{2n + 1} \cdot \left(\sum_{m=1}^{n} y(i - m) + y(i) + \sum_{m=1}^{n} y(i + m) \right)
\end{equation}
Filtr stosowany jest na przedziale $[0, 1023]$ - na jego brzegach danym przypisywana jest jednak wartość 0~(warunki brzegowe). Następnie algorytm wyznacza średnią arytmetyczną zebranych danych na wskazanym przez użytkownika przedziale poszukiwań i~przeprowadza iterację po tymże przedziale. Na listingu \ref{lst:pseudo_fit} zaprezentowany został fragment kodu implementujący wspomnianą iterację \cite{baeldung_fit}. Znajdowane są jedynie te maksima, których wartość przekracza wyznaczoną wcześniej średnia. Ponadto, przechowywana w~danym momencie wartość maksimum jest dodawana do tablicy znalezionych ekstremów tylko wtedy, gdy algorytm znajduje punkt o~wartości mniejszej niż wyznaczona średnia - dzięki temu możliwe jest uniknięcie sytuacji, w~której pojedyncze maksimum znajdowane jest, z~uwagi na zaszumienie wokół niego, wiele razy. Jeśli algorytm znajdzie wiele maksimów, co możliwe jest np. gdy użytkownik niepoprawnie dobierze zakres poszukiwań w~sytuacji podobnej do tej zaprezentowanej na rysunku \ref{fig:spectrum_error}, to ostatecznie wybierane jest to położone najbliżej prawej strony przedziału poszukiwań. Jeśli nie zostanie znalezione żadne maksimum, to zwracana jest wartość domyślna, równa 500. 

\lstinputlisting[
    language=C++, 
    caption={Fragment kodu w~języku C++ prezentujący algorytm pozwalający na znajdowanie maksimum lokalnego na zadanym obszarze poszukiwań.}, 
    label={lst:pseudo_fit}
]{5_code/code_samples/new_peak_finder.cpp}

Bardzo istotnym parametrem nowego algorytmu jest szerokość przedziału wykorzystywanego przez filtr ruchomej średniej (tzn. wartość $2n + 1$, zgodnie z~oznaczeniami przyjętymi na zaprezentowanym wcześniej wzorze). Autorzy zdecydowali się umożliwić użytkownikowi dostosowanie algorytmu do jego potrzeb, dodając do systemu GGSS nowy parametr \lstinline{smoothingWindowHalf}. Odpowiada on bezpośrednio obecnej we wzorze wartości $n$, tzn. połowie przedziału wykorzystywanego przez filtr. Dzięki temu możliwe jest m.in. łatwe wyłączenie mechanizmu wygładzania (poprzez przypisanie parametrowi wartości 0). Autorzy przygotowali komendy pozwalające na pobranie oraz modyfikację tego parametru, co zostało przedstawione na rysunku \ref{fig:smoothing_param}. Parametr ten możliwy jest również do przekazania za pośrednictwem pliku konfiguracyjnego systemu GGSS. Jego obecność, z~uwagi na konieczność zachowania kompatybilności wstecznej, nie jest jednak wymagana - w~przypadku jego braku stosowana jest wartość domyślna.

\begin{figure}[H]
\centering

\begin{subfigure}{0.45\textwidth}
\centering
\includegraphics[width=\textwidth]{smoothing_get.png}
\caption{Pobranie wartości parametru.}
\label{fig:smoothing_get}
\end{subfigure}
\begin{subfigure}{0.45\textwidth}
\centering
\includegraphics[width=\textwidth]{smoothing_set.png}
\caption{Ustawienie wartości parametru.}
\label{fig:smoothing_set}
\end{subfigure}

\caption{Przykład zastosowania przesyłanych do systemu GGSS za pomocą protokołu DIM komend w~celu pobranie oraz modyfikacji parametru \lstinline{smoothingWindowHalf}.}
\label{fig:smoothing_param}
\end{figure}

Zaimplementowane rozwiązanie zostało szczegółowo przetestowane, zarówno w~przypadku wykonywania dopasowania dla rozkładów jednomodalnych, jak i~dwumodalnych. Przeprowadzone testy pozwoliły autorom stwierdzić, że sprawdza się ono dobrze i~nie powoduje żadnych błędów, rozwiązując jednocześnie zaprezentowany powyżej problem.


\clearpage
\subsection{Zmiany w~sposobie aktualizacji parametrów i~zebranych danych}
W~swojej oryginalnej wersji system GGSS nie udostępniał możliwości aktualizacji niektórych parametrów oraz zebranych danych na żądanie - następowało to jedynie w~ściśle określonych momentach działania systemu, takich jak zakończenie pomiaru za pomocą danego licznika słomkowego. Zadaniem autorów była rozbudowa projektu o~możliwość aktualizacji na żądanie parametrów, takich jak monitorowane na danym liczniku napięcie, oraz danych w~postaci zebranego widma.

Aktualizacja parametrów na żądanie osiągnięta została za pomocą komend wysyłanych przez użytkownika za pośrednictwem protokołu DIM. Istniejąca w~oryginalnej wersji projektu komenda \lstinline{update} dokonywała jedynie przesłania do systemu WinCC OA znajdującej się w~pamięci struktury. Autorzy rozbudowali ją o~wywołanie funkcji \lstinline{UpdateAllCurrentlyMeasuredChannelsHVData}, która przed wysłaniem informacji dokonuje aktualizacji danych związanych z~wykorzystywanymi w~projekcie zasilaczami wysokiego napięcia poprzez wykonanie zapytania za pomocą dostarczonych przez producenta urządzenia komend. Pozyskiwane w~ten sposób dane to: monitorowane oraz ustawione napięcie oraz monitorowane natężenie prądu - w~przypadku dwóch pierwszych parametrów wynikowe wartości możliwe są do zaobserwowania na dostępnym w~systemie WinCC OA panelu (rys. \ref{fig:hv_params}).

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{params_hv.png}
\caption{Fragment panelu dostępnego w~ramach technologii WinCC OA, zawierającego dane dotyczące wykorzystywanych w~systemie liczników słomkowych. Charakteryzujący się mniejszą przezroczystością fragment rysunku zawiera parametry \emph{HV} oraz \emph{HV mon.}, mogące podlegać aktualizacji dzięki wprowadzonym przez autorów zmianom.}
\label{fig:hv_params}
\end{figure}

Działanie najnowszej wersji komendy \lstinline{update} zaprezentowane zostało na rysunku \ref{fig:hv_on_demand} - przedstawia on fragmenty dwóch paneli dostępnych w~ramach systemu WinCC OA. Panel znajdujący się po prawej stronie rysunku służy to wysyłania do systemu GGSS komend za pomocą protokołu DIM. Przedstawiony zrzut ekranu wykonany został w~krótkim czasie po uruchomieniu aplikacji, przed zakończeniem pierwszego wykonywanego pomiaru - stąd widoczne są wartości 0.0. Po wykonaniu komendy \lstinline{update} dokonana została natomiast aktualizacja, w~wyniku której pozyskane zostały aktualne wartości napięć dla wszystkich wykorzystanych kanałów - dzięki temu możliwa była obserwacja wartości dla kanału oznaczonego numerem 3, za pomocą którego wykonywany był w~danym momencie pomiar, a~zatem napięcie zostało znacznie zwiększone. W~pierwotnej wersji systemu wykonanie polecenia \lstinline{update} nie spowodowałoby aktualizacji tych wartości - miałoby to miejsce dopiero po zakończeniu pomiaru na kanale numer 3.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{on_demand.png}
\caption{Fragmenty dwóch paneli dostępnych w~ramach technologii WinCC OA. Widoczna jest wysoka wartość napięcia odnotowana dla kanału numer 3~po wykonaniu komendy \lstinline{update}. W~swojej oryginalnej wersji zaprezentowane polecenie nie dokonałoby aktualizacji parametrów związanych z~zasilaczami wysokiego napięcia.}
\label{fig:hv_on_demand}
\end{figure}

W~systemie istnieje ponadto polecenie \lstinline{update channel <kanał>}, pozwalające dokonać aktualizacji tylko dla jednego, wybranego licznika. Zostało ono w~podobny sposób rozbudowane przez autorów o~funkcjonalność aktualizacji wartości parametrów związanych z~pracą zasilaczy wysokiego napięcia. Fragment przygotowanego przez autorów kodu, odpowiedzialnego za pozyskanie od zasilacza odpowiednich danych i~umieszczenie ich w~strukturze przesyłanej za pomocą protokołu DIM, przedstawiony został na listingu \ref{lst:on_demand}.

\lstinputlisting[
    language=C++, 
    caption={Fragment kodu wchodzącego w~skład biblioteki \emph{ggss-lib}, którego zadaniem jest pobranie aktualnych wartości napięć i~natężenia prądu dla pojedynczego kanału zasilacza oraz umieszczenie ich w~strukturze używanej do komunikacji za pomocą protokołu DIM.}, 
    label={lst:on_demand}
]{5_code/code_samples/on_demand.cpp}

W~najnowszej wersji systemu aktualizacja parametrów dla wszystkich kanałów biorących udział w~pomiarach wykonywana jest ponadto po uruchomieniu systemu (ang. \emph{on start}) - w~oryginalnej wersji systemu po uruchomieniu aplikacji, aby otrzymać dane, należało odczekać do zakończenia pierwszego pomiaru wykonywanego za pomocą danego licznika słomkowego. System wykonuje aktualizację również za każdym razem, gdy otrzyma od użytkownika poprawną komendę SET modyfikującą parametry zasilaczy wysokiego napięcia.

Autorzy rozszerzyli aplikację \lstinline{ggss-runner} o~szereg komend pozwalających użytkownikowi na prowadzenie zaawansowanej interakcji z~systemem. Najważniejsze z~nich to:
\begin{itemize}
\item \lstinline{update all_straws} - dokonuje aktualizacji parametrów dla wszystkich liczników słomkowych, niezależnie od tego czy są one używane do wykonywania pomiarów
\item \lstinline{update spectrum} - dokonuje aktualizacji na żądanie widma zebranego przy pomocy licznika słomkowego wykorzystywanego w~danym momencie do wykonywania pomiaru, 
\item \lstinline{update all} - kombinacja komend \lstinline{update} i~\lstinline{update spectrum}
\end{itemize}

Z~punktu widzenia niniejszej pracy szczególnie istotne jest polecenie \lstinline{update spectrum}, pozwalające pozyskać zebrane do momentu jego wykonania dane (widmo) dla kanału aktualnie używanego do przeprowadzania pomiaru. W~pierwotnej wersji systemu GGSS nie istniała możliwość uzyskania zebranych danych przed zakończeniem pomiaru wykonywanego za pomocą danego licznika słomkowego. Ponieważ czas trwania pojedynczego pomiaru może sięgać nawet 10 minut, konieczne było zaimplementowanie mechanizmu pozwalającego użytkownikowi zobaczyć zebrane dane w~czasie jego trwania. Przykład zastosowania przygotowanego polecenia przedstawiony został na rysunku \ref{fig:spectrum_update}.

\begin{figure}[H]
\centering

\begin{subfigure}{0.66\textwidth}
\centering
\includegraphics[width=\textwidth]{spectrum_update_1.png}
\caption{Efekt pierwszego wywołania komendy \lstinline{update spectrum} - widoczna niewielka ilość zebranych przez system danych.}
\label{fig:spectrum_update_1}
\end{subfigure}

\vspace*{8pt}%

\begin{subfigure}{0.66\textwidth}
\centering
\includegraphics[width=\textwidth]{spectrum_update_2.png}
\caption{Efekt drugiego wywołania komendy \lstinline{update spectrum} - widoczna większa ilość danych niż w~przypadku wywołania pierwszego.}
\label{fig:spectrum_update_2}
\end{subfigure}

\caption{Przykład aktualizacji na żądanie zebranych danych: fragment panelu przedstawiającego dane w~postaci histogramu, dla dwóch następujących po sobie w~pewnym odstępie czasu użyć komendy \lstinline{update spectrum}.}
\label{fig:spectrum_update}
\end{figure}

\clearpage
\subsection{Zabezpieczenie przed przepełnieniem bufora urządzenia MCA}
Zbierane przez system GGSS dane, przed przekształceniem ich do postaci histogramu, przechowywane są w~buforze urządzenia MCA dokonującego pomiar. Stosowana w~projekcie konfiguracja pozwala na jednoczesne przechowywanie informacji o~około 30000 zliczeniach. Przeprowadzane testy wykazały, że dla pewnych konfiguracji projektu liczba ta nie jest wystarczająca - zaprezentowane zostało to na rysunku \ref{fig:mca_1}, gdzie wartość \emph{Peak area}, stanowiąca sumę liczebności przedziałów histogramu w~pobliżu maksimum lokalnego, wynosi 27235 dla licznika o~numerze 3. Niezależnie od zwiększania czasu trwania pomiaru, wartość ta nie ulegała zwiększeniu, ponieważ nowe dane były odrzucane z~powodu przepełnienia wspomnianego już bufora. Należy zaznaczyć, że rozwiązanie zaprezentowanego problemu musiało zostać zrealizowane po stronie warstwy oprogramowania systemu - jakiekolwiek zmiany w~warstwie sprzętowej nie były na tym etapie możliwe.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{mca_1.png}
\caption{Przykład prezentujący problem przepełnienia bufora urządzenia MCA: dla odpowiednio długiego czasu trwania pomiaru wartość \emph{Peak area} dla licznika słomkowego oznaczonego numerem 3~osiąga wartość 27000 i~nie ulega zwiększeniu wraz z~wydłużaniem czasu zbierania danych.}
\label{fig:mca_1}
\end{figure}

Przygotowane przez autorów rozwiązanie oparte zostało na okresowym przenoszeniu danych zawartych w~buforze urządzenia MCA do znajdującej się w~pamięci RAM komputera struktury. Dzięki temu wspomniany bufor może być regularnie opróżniany, co chroni przed jego przepełnieniem. W~pierwotnej wersji systemu, po rozpoczęciu pomiaru odpowiedzialny za niego wątek przechodził w~stan oczekiwania na zakończenie operacji (lub otrzymanie sygnału STOP zatrzymującego zbieranie danych). Zaproponowana przez autorów modyfikacja polega na podziale czasu oczekiwania na mniejsze odcinki, na końcu których zebrane dane przenoszone są do pamięci RAM. Uproszczona na potrzeby niniejszego manuskryptu implementacja tego algorytmu zaprezentowana została na listingu \ref{lst:mca} - stosowany w~projekcie algorytm uwzględnia ponadto kilka dodatkowych aspektów działania systemu, takich jak konieczność dokonania w~połowie trwania pomiaru aktualizacji urządzenia ELMB za pośrednictwem systemu WinCC OA i~protokołu DIM.

\lstinputlisting[
    language=C++, 
    caption={Uproszczona na potrzeby manuskryptu implementacja rozwiązania problemu przepełniającego się bufora - w~określonych odstępach czasu wywoływana jest funkcja \lstinline{GetData}, której działanie polega na przeniesieniu danych znajdujących się w~buforze urządzenia MCA do pamięci RAM, przy jednoczesnym jego opróżnieniu.}, 
    label={lst:mca}
]{5_code/code_samples/mca.cpp}

Okres wykonywania operacji przenoszenia zebranych danych określany jest w~sekundach za pomocą parametru \lstinline{mcaRefreshInterval}, który może zostać umieszczony w~pliku konfiguracyjnym lub przekazany do systemu za pomocą komendy. W~celu zachowania kompatybilności wstecznej z~poprzednimi wersjami projektu parametr ten jest opcjonalny - jego brak lub przypisanie mu wartości 0~oznacza działanie systemu bez wprowadzonej poprawki (fladze \lstinline{shouldRefreshMca} przypisywana jest w~takim wypadku wartość \lstinline{false}). Aby pobrać wartość tego parametru należy za pomocą protokołu DIM wysłać do systemu komendę \lstinline{get mcaRefreshInterval}. Modyfikacja jego wartości wykonywana jest natomiast za pomocą polecenia \lstinline{set ggss parameter mcaRefreshInterval value <oczekiwana_wartość>}. 

Przygotowane rozwiązanie zostało przez autorów poddane testom w~środowisku docelowym. Na rysunku \ref{fig:mca_2} przedstawione zostało działanie systemu GGSS w~sytuacji, gdy parametr \lstinline{mcaRefreshInterval} przyjmuje wartość niezerową - bufor urządzenia MCA nie ulega przepełnieniu, o~czym świadczy wysoka (przekraczająca 32768) wartość parametru \emph{Peak area} dla danych zebranych za pomocą liczników słomkowych oznaczonych numerami 2~oraz 4.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{mca_2.png}
\caption{Działanie systemu GGSS po wprowadzeniu przez autorów rozszerzenia jego możliwości o~cykliczne przenoszenie zebranych danych z~bufora urządzenia MCA do pamięci RAM komputera. W~przypadku liczników oznaczonych numerami 2~oraz 4~widoczna jest przekraczająca wartość 32768 liczba zliczeń, co świadczy o~tym, że nie dochodzi do przepełnienia wspomnianego bufora.}
\label{fig:mca_2}
\end{figure}

\subsection{Możliwość przywracania domyślnej kolejności liczników słomkowych}

Kolejność, w~jakiej poszczególne liczniki słomkowe wykorzystywane są do przeprowadzania pomiarów, stanowi możliwy do modyfikacji przez użytkownika parametr systemu GGSS. Manipulowanie nim możliwe było już w~oryginalnej wersji projektu. Autorzy wprowadzili jednak dodatkowo możliwość zapamiętania jego oryginalnej, odczytanej z~pliku konfiguracyjnego, wartości, dzięki czemu możliwe jest jej przywrócenie. Służy do tego dodana do systemu komenda \lstinline{reset channelsOrder}, którą wykonać można, gdy aplikacja nie przeprowadza żadnych pomiarów (tzn. gdy system znajduje się w~stanie zatrzymania). Na potrzeby zilustrowania tej funkcjonalności rozważony zostanie przykład, w~którym aplikacja uruchamiana jest z~domyślną kolejnością ustaloną jako \lstinline{0:3,0:6,0:4,0:2,0:5,0:1}. Następnie użytkownik za pomocą specjalnego panelu (rys. \ref{fig:order_change}) dokonuje zmiany kolejności na obejmującą mniejszą liczbę liczników słomkowych: \lstinline{0:3,0:6,0:4}.


\begin{figure}[H]
\centering
\includegraphics[width=0.4\textwidth]{order_change.png}
\caption{Dostępny w~ramach infrastruktury WinCC OA panel pozwalający na modyfikację kolejności, w~jakiej poszczególne liczniki słomkowe wykorzystywane są do przeprowadzania pomiarów.}
\label{fig:order_change}
\end{figure}


Po zmianie kolejności użytkownik dokonuje próby przywrócenia jej domyślnej wartości za pomocą komendy \lstinline{reset channelsOrder} - w~zależności od tego, czy system GGSS jest w~tym momencie zatrzymany, komenda ta zwróci błąd (gdy nie jest - rys. \ref{fig:order_com_1}) lub wynik pozytywny (gdy jest - rys. \ref{fig:order_com_2}). Ponadto użytkownik ma możliwość sprawdzenia w~dowolnym momencie przechowywanej w~systemie wartości - służy do tego komenda \lstinline{get defaultChannelsOrder}, której działanie zaprezentowane zostało na rysunku \ref{fig:order_com_3}. Funkcjonalność ta została ponadto zintegrowana w~postaci przycisku \emph{Get default} z~przedstawionym na rys. \ref{fig:order_change} panelem. Autorzy nie brali jednak bezpośredniego udziału w~rozwoju infrastruktury opartej o~technologię WinCC OA - podczas przeprowadzania wspomnianej integracji pełnili jedynie rolę konsultacyjną.

\begin{figure}[H]
\centering

\begin{subfigure}{0.45\textwidth}
\centering
\includegraphics[width=\textwidth]{reset_order_1.png}
\caption{Błąd wykonania komendy resetującej.}
\label{fig:order_com_1}
\end{subfigure}
\begin{subfigure}{0.45\textwidth}
\centering
\includegraphics[width=\textwidth]{reset_order_2.png}
\caption{Poprawne wykonanie komendy resetującej.}
\label{fig:order_com_2}
\end{subfigure}

\vspace*{8pt}%

\begin{subfigure}{0.45\textwidth}
\centering
\includegraphics[width=\textwidth]{get_order.png}
\caption{Działanie komendy pozwalającej na pobranie domyślnej kolejności.}
\label{fig:order_com_3}
\end{subfigure}

\caption{Przykłady zastosowania przesyłanych do systemu GGSS za pomocą protokołu DIM komend służących do operacji na domyślnej kolejności, w~jakiej poszczególne liczniki słomkowe wykorzystywane są do przeprowadzania pomiarów.}
\label{fig:order_com}
\end{figure}


\subsection{Pomniejsze rozszerzenia}
Poza opisanymi do tej pory zmianami, autorzy wprowadzili w~projekcie kilka pomniejszych rozszerzeń - przykładem tego typu modyfikacji jest rozbudowa możliwości biblioteki \emph{caenhv-lib}, odpowiedzialnej za wysokopoziomową implementację komunikacji z~zasilaczami wysokiego napięcia. Zmiana ta polegała przede wszystkim na umożliwieniu pozyskiwania i~modyfikowania większej liczby parametrów urządzeń. W~pierwotnej wersji biblioteka pozwalała jedynie na uzyskanie najbardziej istotnych informacji, takich jak wartość monitorowanego na danym kanale napięcia. Wykorzystywane w~projekcie zasilacze CAEN N1470 oferują natomiast bardzo rozbudowaną możliwość konfiguracji, obejmującą m.in. prędkość przyrostu i~spadku napięcia po dokonaniu zmiany jego oczekiwanej wartości. Autorzy rozbudowali więc bibliotekę o~dodatkowe funkcje pozwalające na manipulację tego typu parametrami. Zmiana ta jest istotna z~punktu widzenia opisanej w~sekcji \ref{ch:hv} biblioteki obsługującej komendy wysyłane do zasilaczy - w~celu wykonania operacji na urządzeniu wykorzystuje ona bowiem obiekty klas udostępnianych przez bibliotekę \emph{caenhv-lib}. W~swojej aktualnej wersji poddana rozbudowie biblioteka wspiera niemal wszystkie udostępniane przez producenta parametry zasilaczy.
